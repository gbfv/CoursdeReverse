\documentclass{book}
\usepackage{amsmath, amsfonts,stmaryrd}

\usepackage{xspace}
\usepackage{minted}
\usemintedstyle{xcode}

\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes}

\usepackage{mdframed}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{fancyvrb}
\newcounter{Qcours}

\usepackage{graphicx}
\graphicspath{{img}}

\newenvironment{memory}{%
	\noindent
	\VerbatimEnvironment\stepcounter{Qcours}%
	\begin{VerbatimOut}{mem/\theQcours.mem}%
	}{\end{VerbatimOut}%
	\input{|"python3 memory.py mem \theQcours"}%
}

\newenvironment{commentaire}[1]{%
	\def\FrameCommand{\fboxrule=\FrameRule\fboxsep=\FrameSep \fcolorbox{yellow!50}{yellow!10}}%
	\MakeFramed {\advance\hsize-\width \FrameRestore}
	\noindent {\bf #1}\\
}%
{\endMakeFramed}


\newenvironment{formalisme}[1]{%
	\def\FrameCommand{\fboxrule=\FrameRule\fboxsep=\FrameSep \fcolorbox{red!10}{red!5}}%
	\MakeFramed {\advance\hsize-\width \FrameRestore}
	\noindent {\bf #1}\\
}%
{\endMakeFramed}

\newenvironment{exercice}[1]{%
	\def\FrameCommand{\fboxrule=\FrameRule\fboxsep=\FrameSep \fcolorbox{blue!20}{blue!5}}%
	\MakeFramed {\advance\hsize-\width \FrameRestore}
	\noindent {\bf #1}\\
}%
{\endMakeFramed}

\usepackage{scontents}

\newcommand{\python}{\textsc{python}\xspace}
\newcommand{\pintool}{\textsc{pintool}\xspace}
\newcommand{\C}{\textsc{C}\xspace}
\newcommand{\java}{\textsc{Java}\xspace}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\str}[1]{\texttt{\upquote{#1}}}

\newcommand{\eip}{{\tt eip}\xspace}
\newcommand{\rip}{{\tt rip}\xspace}
\newcommand{\eax}{{\tt eax}\xspace}
\newcommand{\ebx}{{\tt ebx}\xspace}
\newcommand{\ecx}{{\tt ecx}\xspace}
\newcommand{\edx}{{\tt edx}\xspace}
\newcommand{\rax}{{\tt rax}\xspace}
\newcommand{\rbx}{{\tt rbx}\xspace}
\newcommand{\rcx}{{\tt rcx}\xspace}
\newcommand{\rdx}{{\tt rdx}\xspace}
\newcommand{\ax}{{\tt ax}\xspace}
\newcommand{\rcs}{{\tt cs}\xspace}
\newcommand{\rds}{{\tt ds}\xspace}
\newcommand{\rfs}{{\tt fs}\xspace}


\newcommand{\hexa}[1]{{\tt #1}}
\newcommand{\bina}[1]{{\tt 0b#1}}

\newcommand{\REG}{{\tt REG}\xspace}
\newcommand{\BYTE}{{\tt BYTE}}
\newcommand{\WORD}{{\tt WORD}}
\newcommand{\DWORD}{{\tt DWORD}}
\newcommand{\QWORD}{{\tt QWORD}}
\newcommand{\vReg}{{\mathfrak{R}}}
\newcommand{\Memory}{{\mathfrak{M}}}


\newcommand{\Addr}{{\mathbf{Addr}}}
\newcommand{\Reg}{{\mathbf{Reg}}}
\newcommand{\Seg}{{\mathbf{Seg}}}

\newcommand{\N}{{\mathbb{N}}}

\newcommand{\Windows}{{\sc windows}}

\newcommand{\Configuration}{{\mathbf{Configuration}}}


\newcommand{\xquatre}{{\tt x86}\xspace}
\newcommand{\sema}[1]{{\llbracket #1 \rrbracket}}

\begin{document}
	
\section*{Une minute d'attention}

Le sujet de ce cours est d'étudier les logiciels malveillants et surtout les techniques que ceux-ci mettent en \oe uvre. Pour bien comprendre ces plaies de l'informatique, il faut prendre le point de vue adverse, mais l'objet du cours reste bien la défense contre les logiciel malveillants. 

L'auteur de ce cours décline toute responsabilité du fait de son emploi à d'autres fins que la défense contre les logiciels malveillants. Rappelons que toute action s'appuyant sur l'emploi d'un logiciel malveillant est punie par la loi. 

D'autre part, je fais l'hypothèse que vous connaissez le langage \C et le langage \python. Je n'utilise pas de constructions très sophistiquées, mais les bases sont requises.

Décrire le fonctionnement complet d'une machine est hors de portée d'un document comme celui ci. Il faudrait une bibliothèque entière pour le faire, et une bibliothèque qui changerait à chaque seconde. Nous ferons  quelques fois des approximations dont l'unique but est de rester simple. Sans quoi, on se noit dans les détails de fonctionnement d'une machine en perdant de vue ce qui est important. L'idée directrice est de donner de quoi raisonner sur le fonctionnement d'un programme, pas de décortiquer le fonctionnement d'un ordinateur. \'Evidemment, comme le programme est exécuté sur l'ordinateur, le fonctionnement de ce dernier ne peut être complètement oublié, mais l'abstraction est le meilleur moyen de pouvoir continuer à travailler.

\medskip
Bonne lecture,

\chapter{Prérequis}

\section{Notations} \label{sec:notations}

Nous utilisons par la suite un certain nombre de notations. Essayons de toutes les grouper ici.

%\'Etant donné deux entiers $a \leq b$, on note $[a, \ldots, b] =\{x \in \ZZ \mid a \leq x \leq b\}$. Et $[a, \ldots, b[ = \{ x \in \ZZ \mid a \leq x < b\}$.

\'Etant donné deux ensembles $X$, $Y$ et $y \in Y$, on note $\underline{y} : X \to Y$ la fonction $x \in X \mapsto y$. \'Etant donné une fonction $f : X \to Y$, $x \in X$ et $y \in Y$, on note $f[x \mapsto y] : X\to Y $ la fonction définie par
$$\left\{
\begin{array}{ll}
x' \mapsto f(x') & \text{ pour tout } x' \in X \text{ tel que }x' \neq x\\
x \mapsto y & \text{ sinon}.
\end{array}\right.$$

\'Etant donné une fonction $f : X \to Y$, des éléments $x_1, \ldots, x_k \in X$ et $y_1,\ldots, y_k \in Y$, 
on peut composer les fonctions $f[x_1 \mapsto y_1, x_2 \mapsto y_2, \ldots, x_k \mapsto y_k] = $
$$\left( (f[x_1 \mapsto y_1])[x_2 \mapsto y_2]\cdots\right)[x_k\mapsto y_k].$$ 

Quand les éléments $x_1, \ldots, x_k$ sont deux à deux distincts, l'ordre importe peu. Par exemple : 
$$f[x_1\mapsto y_1, x_2 \mapsto y_2] = f[x_2\mapsto y_2, x_1 \mapsto y_1].$$

%\begin{formalisme}{Structures de données}
Nous notons pour la suite $\BYTE$ l'ensemble des octets ("byte" en anglais), c'est-à-dire les entiers entre $0$ et $2^8 -1$, $\WORD$ l'ensemble des mots ("word"), les entiers entre $0$ et $2^{16} - 1$,  $\DWORD$ l'ensemble des mots doubles, les entiers entre $0$ et $2^{32} -1$ et  $\QWORD$ l'ensemble des mots quadruples, les entiers entre $0$ et $2^{64} - 1$.
%\end{formalisme}

Etant donné une fonction $M: \QWORD \to \BYTE$, et un entier $a$, on utilise de temps en temps la notation $M[a] = M(a)$ selon qu'on a un penchant d'informaticien ou de mathématicien. \'Etant donnés deux entiers $a \leq b$, $M[a:b] = (M[a], \ldots, M[b-1])$ est la suite des éléments de $M$ entre $a$ et $b$, la suite étant vide si $a=b$. 

On rappelle que dans le modèle little-endian, étant donné $a\in \QWORD$ et $M: \QWORD\to \BYTE$, $$\begin{array}{rcl}
M_2(a) &=& M[a] + M[a+1] \times 256\\
M_4(a) &=& M[a] + M[a+1]\times 256 + M[a+2]\times 256^{2} +M[a+3]\times 256^{3} \\
M_8(a) &=& \sum_{i = 0}^7 M[a+i] \times {256}^{i}\\
\end{array}$$
désignent respectivement le mot, le mot double, le mot quadruple stocké à l'adresse $a$. Par la suite, quand le contexte est clair, on va oublier les indices $2, 4$ et $8$. 

Nous écrivons régulièrement les nombres dans deux formes, la forme décimale et la forme hexadécimale. L'intérêt de la seconde est l'alignement entre l'écriture du nombre et ses octets. Par exemple, le nombre (en version décimale) $a = 98743326112$ s'écrit en hexadécimal   \hexa{16fd8f95a0} et l'on retrouve chaque octet comme suit \hexa{16 fd 8f 95 a0}. 
 
 Par la suite, les hexadécimaux sont présentés avec une fonte de machine à écrire, et les décimaux avec la fonte usuelle. 
 
%On utilise aussi $mem[a:b[ = (mem[a], \ldots, mem[b-1])$, la suite étant vide si $a = b$. 

\begin{commentaire}{Questions/observations}
	Par la suite, vous verrez des blocs en jaune. Ils correspondent à des questions/observations qu'on m'a posées/faites auparavant. 
\end{commentaire}

\begin{formalisme}{Formalisme}
	Les blocs qui sont en rose abordent le problème sous l'angle mathématique/abstrait. Ils sont rédigés à la manière de ce qu'on peut trouver dans un article scientifique. La section notation aurait pu être entièrement en rose. C'eut été un peu lourd.
\end{formalisme}


\chapter{La machine au microscope}

Un ordinateur est l'assemblage de matériels parmi lesquels on trouvera un (ou plusieurs) processeur, des périphériques (claviers, souris, joysticks), de la mémoire (sous diverses formes), un moniteur (qui peut avoir son propre processeur), etc. Au démarrage d'une machine, un premier programme---qualifié de \emph{bootstrap}---met en route le système d'exploitation, lui-même un programme. Le système d'exploitation est en charge d'orchestrer l'utilisation du processeur, une ressource partagée par l'ensemble des programmes. 

Un ordinateur est donc un système qui peut être vu à plusieurs niveaux~ : on peut partir du "hardware", c'est-à-dire du matériel, on peut prendre le "point de vue" du logiciel d'un utilisateur ou celui du système d'exploitation (OS). \'Evidemment, ces niveaux ne sont pas complètement déconnectés les uns des autres. Dans ce chapitre, nous proposons un modèle de la machine qui rend compte du comportement d'un logiciel exécuté en mode "user", le mode le moins privilégié et le plus commun.

Nous ciblons essentiellement le fonctionnement d'un programme sur un processeur \xquatre en version 64 bits, mais les concepts introduits ont une portée plus large. Pour suivre les exemples, il est conseillé d'utiliser une machine virtuelle pour ceux qui auraient une machine sur un autre OS, {\sc linux} pour l'exemple. 


\section{Du matériel au virtuel}

Si la machine est un objet physique, carte mémoire, processeurs, caches, souris, etc, elle peut également être vue comme un objet abstrait, mathématique. Cette abstraction est implémentée conjointement par le processeur et par le système d'exploi\-tation. Chacun est conçu pour que l'utilisateur puisse s'appuyer sur cette abstraction. Quand on écrit un programme, on ne s'occupe pas de la tension sur les bus ou de la taille des barettes mémoires, et c'est bien heureux.

Cette abstraction se révèle extrêmement simple. Notre modèle de machine se réduit à :
\begin{itemize}
	\item de la mémoire virtuelle et
	\item  des registres. 
\end{itemize}

Il y a bien sûr un lien entre les zones de mémoire virtuelle et les caches et autres barrettes physiques de mémoire, mais le programme s'exécute comme s'il \emph{vivait dans le monde virtuel}. Autrement dit, le processeur et l'OS organisent les composants physiques de la machine pour qu'ils apparaissent sous une forme virtuelle auprès des programmes. Pour le programme, l'état de la machine est entièrement décrit par la valeur des registres et la donnée de la mémoire virtuelle. 

Le passage de la mémoire virtuelle à l'architecture physique de la machine va bien au delà de ce polycopié. C'est typiquement l'objet du cours d'architecture. Nous donnerons donc un exposé simplifié du fonctionnement d'une machine. Cette abstraction a un coût: nous ne serons pas en mesure de modéliser des attaques par effet de bord, en particulier celles de type {\sc spectre} qui exploitent des effets de cache, voir par exemple \url{https://spectreattack.com}. %Et plus généralement, le modèle est clairement insuffisant pour gérer l'OS lui même ou un driver (c'est-à-dire un programme en mode kernel). 

%Si on fait abstraction du matériel, et si on se place du point de vue d'un programme en cours d'exécution, l'ordinateur est composé d'un bloc de mémoire de grande taille, dite mémoire virtuelle, et d'un petit nombre de 
%mémoires de petite taille (au plus quelques octets),  les \emph{registres}. 

\subsection{Mémoire virtuelle}

La \emph{mémoire virtuelle} est un tableau de cellules mémoires, chacune possédant donc un index appelé \emph{adresse}. Chaque cellule contient un octet. Sur une machine 64 bits, il y a \emph{potentiellement} $2^{64}$ cellules\footnote{Dans les faits,  l'adressage ne peut se faire que sur 48 bits, voire 52 bits, mais nous pouvons faire \emph{comme s'il} était sur 64 bits.}. Ainsi il existe la cellule à l'adresse \code{0}, celle à l'adresse \code{1}, \code{2}, etc. Avec $64$ bits, la limite est donc de $2^{64} \simeq 2 \times 10^{19}$ octets, c'est-à-dire 20Eo (exa octets). Comme ordre de grandeur, selon T. Landauer, la mémoire de l'ensemble de l'humanité serait de l'ordre d'1Eo. Dans les faits, seule une partie de la mémoire est disponible au programme exécuté. Nous y reviendrons en détail.  Ci-dessous, un exemple de mémoire virtuelle, la première case contenant la valeur \hexa{ab}, la dernière \hexa{ef}. 

\medskip
\begin{memory}
m = Memory(12, 0.5);
m.mark(0, "0")
m.mark(11.3, "ff\^ {}8")
m.content(0, "ab")
m.content(11.3, "ef")
m.content(0.7, "$\ldots$")
\end{memory}

La mémoire est découpée en pages, ce sont des tranches de 4kO octets (c'est-à-dire par blocs de \hexa{1000} = 4096 octets). Chacune dispose de droits spécifiques~: R, W et X, lecture, écriture et exécution (c.f. le manuel de {\tt mprotect} en \C sous Unix). 

Pour se "promener" dans la mémoire, et voir les droits associés, on pourra utiliser le petit code \C suivant sous Windows, pour avoir les droits à l'adresse \hexa{1000000} :
\begin{minted}{C}
MEMORY_BASIC_INFORMATION mbi;
VirtualQuery( (void *) 0x1000000, &mbi, sizeof(mbi));
std::cout << mbi.BaseAddress << " " << std::hex << mbi.Protect;
\end{minted}

Une image un peu plus précise de la mémoire est donc :

\medskip
\begin{memory}
m = Memory(12, 0.6);
m.zone(0, 3, "red!10")
m.zone(3,6, "blue!10")
m.zone(9, 12, "green!10")
m.mark(0, "0")
m.mark(11, "FF\^ {}8")
m.content(0, "AB")
m.content(11, "EF")
m.content(1, "$\ldots$")
m.content(3,"01")
m.mark(3, "0x1000")
m.bar(6)
m.content(4, "$\ldots$")
m.add_node((7,0.25), "$\ldots$")
m.bar(9)
m.mark(6, "0x2000")
\end{memory}
où les couleurs rouge, bleu, vert désignent des droits spécifiques en mémoire. 

\medskip
En plus de ce mécanisme, il y a deux modes d'utilisation du processeur~: le mode "user" et le mode "supervisor" ou "kernel". Dans ce cours, nous travaillons essentiellement en mode "user", c'est le mode de l'utilisateur. Le kernel et les drivers vont agir en mode "supervisor". Certaines instructions et certaines zones de la mémoire ne sont accessible que dans ce mode. 

\begin{formalisme}{La mémoire virtuelle}
En termes mathématiques, l'état de la mémoire virtuelle se décrit comme une paire de fonction $(M,\rho)$ où:
\begin{itemize}
	\item $M : \Addr \to \BYTE$ où $\Addr = \QWORD$ pour une machine 64 bits, et $\DWORD$ pour une machine 32 bits.
	\item $\rho: \Addr \to 2^{\{R, W, X\}}$ associe à chaque adresse les droits associés.
	
On note $\bf{V}$ l'ensemble des fonctions $\Addr \to \BYTE$ et $\bf{D}$ l'ensemble des fonctions $\Addr \to 2^{\{R, W, X\}}$. Et enfin, $\Memory = \bf{V} \times \bf{D}$. C'est l'ensemble de toutes les configurations mémoire de notre modèle. 
\end{itemize}

Etant donné un état de la mémoire $M = (m,\rho) \in \Memory$, on note $M.mem = m$ sa première composante et $M.rights = \rho$ la seconde. Etant donné $a \in \QWORD$, on se permet d'écrire $M[a]$ pour $M.mem(a)$. Nous reprenons les notations de la Section~\ref{sec:notations}.

La gestion des droits page par page se traduit par l'équation $$\rho(x) = \rho(x \ \& \ \tt{ff^6f000}  )$$ pour tout $x\in \Addr$. L'hypothèse est implicite par la suite. 	
\end{formalisme}

\subsection{Registres}
Les registres sont des zones de mémoires directement implantées sur le processeur. Les énumérer devient vite fastidieux. Citons quand même ceux qu'on va retrouver régulièrement. 

Les registres courants sont : {\tt rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, r8, ..., r15, rip, rflags}. Ils font tous 8 octets (64 bits). Ils sont prévus pour contenir des adresses ou des entiers.

Pour les calculs avec les flottants, il y a des registres spécialisés. Ce sont les registres sont {\tt xmm0, ..., xmm7}. Ces registres font 128 bits (et même plus si on considère leurs formes {\tt ymmi} (256 bits) ou {\tt zmmi} (512 bits)). 

\begin{commentaire}{Les registres ont une histoire}
Les quatre premiers registres datent des premiers processeurs {\sc intel}, le 8080, dans les années 1970. Ils faisaient au début 8 bits. Et il fallait les combiner pour obtenir des nombres au dessus de 255.
	
Pour des raisons de retro-compatibilité, ces registres sont toujours accessibles aujourd'hui. Par exemple, le registre {\tt ebx} qui date de l'architecture {\tt Intel-386} (32 bits) correspond aux 32 bits de poids faible du registre {\tt rbx}. Le registre {\tt ax} qu'on retrouve sur {\tt Intel-286} correspond aux 16 bits de poids faible de {\tt rax}. Et enfin, {\tt ah} et {\tt al}, tous deux faisant 8 bits correspondent respectivement aux bits de 8 à 16 et aux bits de 0 à 8 du registre {\tt rax}.
	
En résumé, les 8 octets de {\tt rax} s'énumèrent :
	\begin{center}
		\begin{tikzpicture}
		\draw (0,0) -- (8,0)  -- (8,1) -- (0,1)  --cycle;
		\foreach \i in {1,...,7}{
			\draw (\i,0) -- (\i,1);
		}
		\draw (1,0) -- (1,1);
		\draw (2,0) -- (2,1);
		\draw (3,0) -- (3,1);
		\node (A0) at (6.5,0.5) {\tt ah};
		\node (A0) at (7.5,0.5) {\tt al}; 
		\draw[dashed] (6,1) arc (120:60:2);
		\draw[dashed] (4,0) arc (-120:-60:4);
		\draw[dashed] (0,1) arc (120:60:8);
		\node (Ax) at (6,1.2) {ax};
		\node (Ax) at (6,-0.8) {eax};
		\node (Ax) at (4,1.8) {rax};
		\end{tikzpicture}
	\end{center}
\end{commentaire}

Parmi les registres, il y en a trois qui se distinguent. 
\begin{itemize}
	\item Le registre {\tt rip}, instruction pointer, est le registre qui contient l'adresse de l'instruction à exécuter. 
	\item Le registre {\tt rsp} désigne le "haut de la pile". 
	\item Le registre {\tt rflags} est composé de drapeaux. Le drapeau {\tt ZF} est mis à 1 quand un calcul arithmétique aboutit à 0. Parmi les autres flags : SF, drapeau du signe (1 quand le nombre est positif, 0 s'il est négatif), CF (carry, 1 si l'opération se termine avec une retenue), OF, (overflow, en cas de dépassement de capacité du registre), PF, (parity). 
\end{itemize} 

Il y a combien de registres en {\sc x86}? Disons une centaine, cela dépend de\ldots la manière de compter. Les registres forment tout un zoo qui est le fruit de l'histoire de cette famille de processeurs. Notons toutefois que la plupart d'entre eux sont spécifiques au mode kernel. Pour celles et ceux qui veulent un aperçu du paysage, je suggère \url{https://blog.yossarian.net/2020/11/30/How-many-registers-does-an-x86-64-cpu-have}.

Quelles sont les propriétés des registres ? Premier point, les registres ont donc des tailles spécifiques. Le registre $\rcs$ est un registre dit de segment. Sa taille est de 2 octets. Les registres ${\tt xmm1}, {\tt xmm2}, \ldots$ vus ci-dessus font 16 octets.

\begin{formalisme}{Modèle des registres}
	Par la suite, on note \REG l'ensemble des registres. Au même titre qu'on a défini la valuation des variables, on peut le faire pour les registres. 
	
	\medskip
	Une \emph{valuation} de registres est une fonction dans $\REG \to \QWORD$. On note $\vReg$ l'ensemble des valuations de registres. 
\end{formalisme}

\begin{commentaire}{Erreur ou imprécision ?}
	Dans la description d'une valuation ci-dessus, le registre {\tt xmm0} qui est dans $\REG$ prend ses valeurs dans $\QWORD$ alors qu'il fait 16 octets (2 $\QWORD$ par conséquent). Comment faire mieux ? 
\end{commentaire}
	
Deuxième point. Les registres permettent de désigner des zones de mémoire. Par défaut, la zone est désignée par la valeur du registre. Toutefois, pour les registres de segments, qui ne font deux octets, la zone indiquée est différente. Le registre $\rfs$ par exemple fait référence au mode d'adressage du processeur (via des tables accessibles en mode kernel). L'adresse  donnée par le registre $\rfs$ ne correspond pas à la valeur du registre mais au contenu indexé dans une table. Faisons abstraction de ce mécanisme, nous \emph{ferons comme si} le registre désignait une valeur arbitraire en mémoire. Le petit bout de code qui suit affiche la valeur du registre \code{fs} et à quel endroit il pointe. 

\begin{minted}{c}
unsigned short fs;
asm("mov %%fs, %0" : "=r"(fs));
uint64_t at_fs;
asm ("lea %%fs:(0), %0" : "=r"(at_fs));
printf("fs=%x: fs points to: %lx\n", fs, at_fs);
\end{minted}

%Pour résumer, nous notons $\Reg$ l'ensemble des registres. Pour chaque registre $r\in \Reg$, $|r|$ désigne la taille du registre en nombre d'octets et $[r]$ l'index qu'il désigne en mémoire virtuelle. L'état des registres se décrit alors comme une fonction $R$ qui a chaque registre associe $R(r) \in [0\ldots 256^{|r|}]$ sa valeur et $r \mapsto [r]$ est la fonction d'adressage.  

Etant donné $M \in \Memory$, un état de la mémoire virtuelle, et $R$, l'état des registres,  la notation $M[r] = M.mem(R(r))$ désigne l'octet contenu à l'adresse indiquée par un registre $r \in \Reg$. De même, comme nous l'avons vu en section~\ref{sec:notations}, $M_2[r]$ désigne le mot à la position $r$ et ainsi de suite.  % Par la suite, nous utiliserons la version simplifiée: $M[r]$. 

%Nous revenons sur certains registres en section~\ref{sec:asm}. 

\subsection{Instructions}

\newcommand{\Instr}{{\tt Instr}}

Jusque là, nous avons décrit l'état d'une machine. Attaquons nous maintenant au calcul. Les instructions machines sont les plus petits éléments qui le pilotent.

\begin{formalisme}{Instruction}
Une instruction est une suite d'octets associée à une sémantique (qui spécifie ce que fait l'instruction). 
	
L'ensemble des instructions, noté $\Instr$, a la propriété d'être préfixe. C'est à dire qu'il n'y a pas deux instructions dont l'une est le début de l'autre.  	
\end{formalisme}
Voici un exemple de 6 instructions machine : 
\begin{minted}{asm}
90
55
89, B8
B8, 01, 02, 03, 04
67, 48, 8B, 41, 0C
FF D0
C3
\end{minted}

On peut maintenant résumer le fonctionnement d'une machine.  L'exécution d'un programme procède de la manière suivante. A chaque étape, le processeur lit les cases mémoires $M[\rip], M[\rip+1], M[\rip+2], \ldots$ Trois possibilités :  soit un préfixe\footnote{début de la suite.} de la suite correspond à une instruction machine  et la zone lue a les droits en lectuRe et en eXecution, auquel cas l'instruction est exécutée. Soit il y a un problème de droit ou bien encore la suite ne correspond pas à une instruction, dans ce cas un mécanisme d'exception prend en charge l'erreur. 

Ainsi, si la valeur de  $M[\rip]$ est $\hexa{90}$, le processeur reconnaît l'instruction machine dite \code{nop} qui consiste à ne rien faire\footnote{En fait, elle incrémente tout de même la valeur de \rip\ de $1$. }. Si la suite commence par : \code{48,83,C0,09},  il s'agit de l'instruction qui rajoute $9$ au registre \rax\ et passe à l'instruction suivante\footnote{C'est-à-dire incrémente \rip de $4$.}.  

Le programme  poursuit son exécution tant qu'une \emph{interruption} ne se produit pas. Les interruptions (en règle générale externes au programme en cours) peuvent apparaître à diverses occasions, une instruction illégale comme nous avons vu plus haut, une modification au niveau matériel ou bien une horloge interne. Suite à l'interruption, et selon une certaine politique de priorité, le système d'exploitation "reprend" la main, en d'autres termes, la valeur de \rip est modifiée directement par le processeur, en dehors du contrôle du programme. Le système rendra éventuellement la main au programme plus tard. 

\begin{formalisme}{Exécution}
\'Etant donné une configuration $C = (M, R) \in \Memory \times \vReg$, la machine va lire la suite d'octets à partir de $\rip$. Trois cas : 
\begin{itemize}
	\item Lors de la lecture, il y a une adresse $x \in [\rip, \rip+1, \ldots]$ pour laquelle $X \not\in M.rights[x]$. Une exception est envoyée au système. 
	\item La suite d'octets ne correspond pas à une instruction. Dans ce cas, une exception est également levée. 
	\item Sinon, l'instruction est exécutée. Ce qui a pour effet de modifier la configuration. La modification étant spécifiée par l'instruction elle même.
\end{itemize}
\end{formalisme}

Travailler directement avec des instructions machines peut vite être un exercice de mémoire fastidieux. Nous allons plutôt utiliser une représentation en assembleur de celles-ci. Pour les instructions précédentes : 
%Il y a plusieurs manières de les voir. De manière abstraite, c'est un ensemble qu'on peut lister : 
\begin{minted}{asm}
nop
push rbp
add rax, rbx
mov rax, 0x04030201
mov rax, qword ptr[rcx+12]
call rax
ret
\end{minted}

La correspondance entre le code assembleur et le code machine peut se retrouver sur un site comme : \url{https://defuse.ca/online-x86-assembler.htm}. 

La liste des instructions se trouve dans le(s) manuel(s) du(es) constructeur(s) du processeur. Par exemple, on retrouvera pour INTEL/x86\_64 les instructions à \cite{IntelSetInstruction}. Attention, l'ensemble des instructions varie au cours du temps, certaines apparaissent, d'autres disparaissent. Par la suite, on note $\Instr$ l'ensemble des instructions. 

\begin{commentaire}{Quelques mots sur l'encodage et la structure des instructions}
La structure des instructions  se nomme ISA (Instruction Set Architecture). En \xquatre, une \textit{instruction} se décompose selon le format\footnote{Plus de détails à \url{http://ref.x86asm.net/coder32.html} par exemple.} :%TODO dire qu'en bytes bah c'est quasiment arei
\begin{eqnarray*}
	\Instr& ::=& \code{prefix}_1 \dots \code{prefix}_k \; \code{opcode} \; \code{Arg}_1 \dots \code{Arg}_\ell\\
	\code{Arg} &::=& \code{Imm}\ |\ \Reg\ |\ \code{Mem}\\
	\label{eq3} \code{Mem} &::=& (\Seg[\Reg_1+scale*\Reg_2+\code{Disp}], size)\\ 
	\code{prefix} &:::=& {\tt rep}, {\tt lock}, {\tt data16}, \ldots\\
	\code{opcode} &::=& {\tt add}, {\tt jmp}, {\tt call}, \ldots \\
	\Seg & ::=& {\tt cs}, {\tt ds}, {\tt es}, \ldots \\
	\Reg & ::=& {\tt rax}, {\tt ebx}, \ldots
\end{eqnarray*}
où \code{Imm}, \code{Disp} désignent un immédiat (un nombre), $scale\in\{1,2,4,8\}$ et $size\in\{1, 2, 4, 8\}$. 

Le codage des instructions sous la forme d'octets suit la structure ci-dessus : chaque préfixe est stocké sur un octet. L'opcode désigne l'opération à réaliser. Il est stocké sur un, deux ou trois octets. Ensuite, pour les arguments, les immédiats sont codés tels qu'ils apparaissent en mémoire. Les registres, registres de segments, scale et size et les références en mémoire ont un mécanisme spécifique (voir le codage \code{mod/rm}+sib). Un exemple, l'instruction $$\code{data16 adc [rbx+rcx*4+0x12],0x1357}$$
est encodée \code{66,81,54,8B,12,57,13}: 

\begin{tikzpicture}
\node[draw,shape=rectangle] (A) at (0,0) {66};
\node (Aa) at (0,-0.5) {data16};
\node[draw,shape=rectangle] (B) at (1,0) {81};
\node (Ba) at (1,-0.5) {adc};
\node[draw,shape=rectangle] (C) at (2.5,0) {54 8B};
\node (Ca) at (2.5,-0.5) {rbx + 4*rcx};
\node[draw,shape=rectangle] (D) at (4,0) {12};
\node (Da) at (4,-0.5) {0x12};
\node[draw,shape=rectangle] (E) at (5.5,0) {57 13};
\node (Ea) at (5.5,-0.5) {0x1357};
\end{tikzpicture}
\end{commentaire}


%L'encodage d'une instruction est injectif (dans les suites d'octets). A une instruction correspond un unique encodage. Par la suite, nous ne distinguons plus une instruction de son encodage.
%Enfin, c'est un encodage dit préfixe :  l'encodage est tel qu'il n'y a pas deux instructions différentes dont l'encodage de l'une soit préfixe de l'autre. 

%\subsection{En résumé}

%L'état de la machine est donc décrite par la mémoire virtuelle et les registres. En termes mathématique, il s'agit d'un triplet $(M, \rho, R)$ désignant respectivement la valeur de chaque cellule en mémoire, les droits associés et la valeur des registres. Un tel triplet s'appelle une configuration et on note $$\Configuration = (\Addr \to \BYTE) \times (\Addr \to 2^{\{R,W,X\}}) \times (\Reg \to \BYTE^A)$$ 
%l'ensemble de toutes les configurations. Enfin, étant donnée une configuration $C$, $M_C$ désigne la valuation de sa mémoire, $\rho_C$ ses droits et $R_C$ la valuation de ses  registres. 


%Selon l'usage, on peut "oublier" les droits en mémoire. On obtient alors un modèle moins précis mais plus simple. S'il est suffisant pour rendre compte du phénomène envisagé, il n'y a pas de raisons de se compliquer la vie. Au contraire, si on s'intéresse à l'attaque {\sc spectre}, le modèle avec valeur et droits n'est pas assez précis. Dans ce cas, il faudra rajouter des informations concernant le(s) cache. Pareil, si on doit tenir compte de l'OS--par exemple les appels systèmes, le modèle sera insuffisant. 

%Tout l'art consiste à trouver le bon niveau d'abstraction.

%\section{Une sémantique opérationnelle}

%Les  processeurs modernes de l'architecture {\sc x86} reconnaissent plus d'un millier d'instructions différentes. On ne les décrira pas ici. Toutefois, on pourra observer que chaque instruction lit et modifie un ou plusieurs registres, éventuellement 1, 2, 4 ou 8 octets en mémoire\footnote{\`A l'exception de certaines instructions de manipulation de chaînes comme {\tt rep stosb} qui modifient un nombre arbitraires d'octets, mais ce type d'instruction prend autant de cycles machine.}.  Il n'y a, d'une certaine manière, que huit types de données : 
%\begin{itemize}
%	\item 1 octet = {\tt byte}, 
%	\item 2 octets = {\tt word},
%	\item 4 octets = {\tt dword},
%	\item 8 octets = {\tt qword},
%	\item 10 octets = {\tt tword} pour les flottants en précision étendue,
%	\item 16 octets = {\tt oword}, 32 = {\tt yword} et 64 {\tt zword} pour les registres spécifiques correspondant : {\tt xmm}, {\tt ymm} et {\tt zmm}
%\end{itemize}

%Les autres structures de données du \C, tableaux, listes, chaînes de caractères, etc sont définies à l'aide de ces briques de base.

%Les instructions machine "en font le moins possible". Par exemple, pour une multiplication, il n'y a pas de vérification du type des éléments manipulés, entiers signés ou non, flottants, ni sur la taille: octet, mot, mot double ou quadruple. La machine autorise l'application  de la multiplication des flottants à un octet signé et à un mot non signé.  En d'autres termes, le programmeur doit gérer le type de chaque zone mémoire.

%En conclusion, le code machine, c'est la politique des nombreux petits pas sans filets.  Les langages de plus haut niveau comme \C ou \python permettent de structurer à plus grande échelle les programmes, ils nous rapprochent de la vue algorithmique.  Pour cela, ils nous offrent essentiellement des structures de contrôle de haut niveau, un plus large éventail de données avec un typage et les outils pour les manipuler. 

%\subsection{Sémantique des instructions}
%
%Quel modèle mathématique rend compte du comportement de la machine. Ma\-thé\-matiquement, on fait l'hypothèse que l'on dispose d'une fonction $${\bf step} : \Configuration \to \Configuration$$
%qui exécute une étape de calcul, c'est-à-dire une instruction machine. Cette fonction peut être décrite par la sémantique de chaque instruction séparément. Etant donnée une instruction $I$, on note 
%$$\sema{I}(M,\rho, R)$$ la configuration obtenue après application de l'instruction $I$ sur la configuration $(M,\rho,R)$. 
%
%Par conséquent, pour une configuration $C = (M,\rho, R)$,  
%$${\bf step}(M,\rho,R) = \sema{I}(M,\rho,R)$$ 
%où $I$ est l'instruction à l'adresse $R(\rip)$, par la suite simplifié sous la forme $\rip$ quand le contexte est clair.
%
%
%En outre, autre hypothèse usuelle, la mémoire n'est modifiée qu'en un nombre borné de position. En d'autres termes, il existe $Mmax > 0$ tel que pour toute configuration $C$, $|\{x \in \Addr : M_{{\bf step}(C)}[x] \neq M_C[x] \}| \leq Mmax$ où $|X|$ désigne le cardinal de l'ensemble $X$.
%
%
%\section{L'assembleur pour les nuls}\label{sec:asm}
%
%Faisons un tour d'horizon de l'assembleur X86. 
%
%\subsection{Registres}
%Petit tour (incomplet) des registres. Les registres se classent en plusieurs catégories, les registres généraux sont 
%$$\tt rax, rbx, rcx, rdx, rsi, rdi, r8, r9, \ldots, r15$$
%ils servent à tout et à rien de particulier. Les registres $\tt rsi$ et $\tt rdi$ servent pour les instructions manipulant des chaînes de caractères. Le "s" de $\tt rsi$ vient de "source", le "d" de $\tt rdi$ pour "destination". 
%Les registres
%$$\tt rbp, rsp$$
%sont le "base pointer" et le "stack pointer". Le registre $\tt rsp$ donne la position courante sur la pile. Le registre $\tt rbp$ donne la position en mémoire des arguments de la fonction courante. Attention, l'emploi de ces registres est conventionnel\footnote{Chercher "Application Binary Interface" sur le web.}. 
%Le registre
%$$\tt rip$$
%désigne l'instruction courante. Le registre 
%$$\tt rflags$$
%contient l'état des flags. Les flags sont mis à jour pour indiquer des informations sur le calcul. Le bit 0 de $\tt rflags$ qui s'appelle $\tt cf$ pour "carry flag" indique que la dernière opération s'est terminée par une retenue (carry). Deux autres exemples de flags  : bit 6, $\tt zf$ (zero), bit 7, $\tt sf$ (signe). 
%
%Enfin, on rencontrera les registres de segments : 
%$$\tt cs, ds, ed, fs, gs, ss$$
%qui ont eu une fonction importante dans le contexte des machines à addressage sur 16 bits (cs: "code segment", ds : "data segment", ss : "stack segment", etc). Ils ne sont plus employés à l'exception de {\tt fs} et {\tt gs} que nous reverrons plus tard. Ces registres sont utilisés par l'OS pour désigner des zones de mémoire pour la gestion des processus. 
%

\chapter{Rappels en C et assembleur}

Ce chapitre n'est pas un cours d'assembleur, pas plus qu'un cours de C, mais des rappels de ce qui sera utilisé par la suite. 

\section{Assembleur MASM}

Nous présentons l'assembleur {\tt masm}, un des nombreux assembleurs sous \xquatre. Un programme assembleur est donné par une liste d'énoncés, c'est-à-dire des instructions ou des données explicites. 

Le code est structuré sous forme de sections, chacune représentant un bloc de mémoire ayant des droits spécifiques. On va retrouver ainsi traditionnellement une section ".text" pour les instructions, une section ".data" pour les variables globales, etc. 

Commençons par "Hello world" écrit en syntaxe {\tt masm} :

\begin{minted}[linenos]{asm}
.model flat,stdcall ; memory=flat, stdcall = extern function
include \masm32\include\kernel32.inc
includelib \masm32\lib\msvcrt.lib ; Some default includes :P
printf proto C :vararg 	; declaration of printf usage

.data
Text       db "Hello World",0

.code
start:
	mov eax, offset Text
	push eax ; Push text to the stack
	call printf 
	pop eax ; restore the stack
	push 0 ; Exit code 0 (Success)
	call ExitProcess
end start
\end{minted}

Le code binaire produit contient trois sections, un header, une section ".text" avec des droits RX qui contient les instructions (mentionné \code{.code}, ligne 9), une section ".data" qui contient les variables globales du programme (mentionné \code{.data}, ligne 6). 

Les énoncés comme 
\mint{asm}{Text db "Hello word", 0} décrivent le contenu, octet par octet, de la mémoire à une position nommée "Text". 
Les énoncés comme \mint{asm}{push eax} décrivent le contenu de la mémoire, mais en utilisant la syntaxe assembleur des instructions. Il eut été équivalent d'écrire : 
\mint{asm}{db "P"}
sachant que le code {\tt ascii} de "P" est \code{0x50 == push eax}. 

Venons en maintenant au langage C. 

\section{Manipulations de pointeurs, formats, et joyeusetés}

Quelques lignes à connaître par c\oe ur. 

\begin{minted}[linenos]{C}
int _tmain(int argc, _TCHAR* argv[]){
	int i = 0x12345678, j = 32;
	printf("[%p] = %d, [%p] = %d \n", &i, i, &j, j );
	char *p = (char *) & i;
	for(int k = 0 ; k < 4 ; ++k) printf("%02x ", p[k] & 0xff);
	uint32_t a = (uint32_t) &i;
	int *k = (int *) a;
	k--;
	printf("k = [%p], p = [%p]\n", k);
	*k += 3;//k[0] = 3;
	printf("%d\n", j);
\end{minted}

Dont voici le résultat sur la console : 

\begin{minted}{C}
[0012FF78] = 305419896, [0012FF74] = 32
78 56 34 12 
k = [0012FF74], p = [0012FF77]
35
\end{minted}

Quelques commentaires. 

\begin{itemize}
	\item Ligne 2 : deux déclarations de variables.
	\item Ligne 3 : affichage des pointeurs "\%p", notation "\&p" pour désigner l'adresse ou la variable est stockée. 
	\item Ligne 4 : une conversion de type. Les pointeurs sont des nombres. 
	\item Ligne 5 : le phénomène little-endian. Note : dans \code{"\%02x", p[k] \& 0xff}, le format attend un entier sur 4 octets, or \code{p[k]} n'en fait que 1.
	\item Ligne 7/8/9 : attention à l'arithmétique des pointeurs !
	\item Ligne 10 : un effet de bord. L'"erreur" de la ligne 8 conduit à la modification de la valeur de \code{j}\footnote{Attention, cet effet est fonction du compilateur !}
\end{itemize}

\section{Fonctions}

Un programme en C est une liste de déclarations. Parmi celles-ci, il y a les déclarations de variables et les déclarations de fonctions. Le code résultat, après compilation, garde cette structure globale : les variables globales d'un côté, les fonctions de l'autre. Sauf cas d'"inlining", la structure des fonctions est conservée~: la suite des instructions machines produite se découpe en   morceaux, chacun correspondant à une des fonctions.  Par exemple, le code suivant : 

\begin{minted}{c}
void f1(int x){ .... }
int f2(float y, float z){ ... }
int main(int argc, char **argv){ ... }
\end{minted}

\noindent se retrouvera typiquement en mémoire sous la forme : 

\medskip
\begin{memory}
m = Memory(12, 0.6);
m.mark(3, "f1")
m.mark(4, "f2")
m.zone(3,4, "red!10")
m.zone(4,6, "blue!10")
m.zone(6,9,  "green!10")
m.content(3,"$\ldots$")
m.bar(6)
m.content(4, "$\ldots$")
m.add_node((7,0.25), "$\ldots$")
m.bar(9)
m.mark(6, "main")
\end{memory}

Un pointeur de fonction désigne l'adresse de la première instruction de la fonction. Voici un petit exemple d'emploi d'un pointeur de fonction (les déclarations initiales sont omises) : 

\begin{minted}[linenos]{C}
typedef int (*fun_float_int_to_int)(float,int);
int trunc_prod(float r, int i){ return (int) (r * i); }
...
fun_float_int_to_int f = trunc_prod;
printf("%d", f(3.14f, 4));
\end{minted}

Quelques commentaires : 

\begin{itemize}
	\item Ligne 1 : déclaration du type des fonctions, 
	\item Ligne 4 : déclaration d'une variable "fonction",
	\item Ligne 5 : appel de la fonction via la variable. 
\end{itemize}

\paragraph{Décoration sur les déclarations de fonctions }

Deux décoration utilisées de temps en temps. 

\begin{minted}[]{C}
__declspec(noinline) int f(float r){...} //ne doit pas être inlinée
__declspec(naked) void f(){...}   //compilée sans sauvegarde de rbp
\end{minted}

La première évite que la fonction ne soit "inlinée", qu'elle "disparaisse" du fait de la compilation. Pour la seconde, le compilateur ne rajoutera pas la mise en place du frame de la fonction. 

\section{Assembleur}

En \xquatre, il y a beaucoup d'instructions. Hors de question  donc de les présenter de manière exhaustive. Voyons les plus courantes. 

\subsection{Instructions}
Commençons par les affectations. En commentaire, on propose leur "équivalent" en C. Voici certaines formes d'affectation :  
\begin{minted}{asm}
mov rax, 0x1234     ; rax = 0x1234
mov rbx, rax        ; rbx = rax
mov rbx, [0x1234]   ; rbx = *((qword *) 0x1234)
mov ebx, [0x1234]   ; ebx = *((dword *) 0x1234) 
mov ebx, dword ptr[0x1234] ; autre forme de l'instruction précédente
mov bx, [0x1234]    ; bx = *((word *) 0x1234 )
mov bl, [0x1234]    ; bl = *((byte *) 0x1234)
mov rbx, [rax]      ; rbx = *((dword *) rax)
mov rbx, [rax+4*rcx+0x12] ; rbx = *((dword *) (rax + 4*rcx +0x12))
mov rbx, fs:[0x30]  ; rbx = [fs+0x30]
lea rax, [rbx+4*rcx+0x12] ; rax = rbx + 4*rcx + 0x12
\end{minted}

Quelques opérations arithmétiques : 
\begin{minted}{asm}
xor eax, eax    ; eax ^= eax or eax = 0
add rax, rbx    ;  rax += rbx
sub rax, 0x12   ; rax -= 0x12
imul rax, [rbx] ; signed mul, rax *= [rbx] seen as qword 
imul rbx        ; rax *= rbx (rax is implicit) 
mul rbx         ; unsigned mul, rax *= rbx 
fmul [rsp+8]    ; floating point multiplication (st(0) is implicit)
idiv  [0x1234]  ; ah = rax / *(0x1234), al = rax % *(0x1234)
\end{minted}
Ces opérations vont modifier le registre des flags (carries, zero, etc). Mais il y a deux instructions spécifiques pour la mise à jour des flags : 
\begin{minted}{asm}
cmp rax, rbx    ; ZF == (rax - rbx == 0), SF == (rax - rbx > 0)
cmp rax, 0x12   ; 
test rax, rbx   ; ZF == (rax & rbx == 0)
\end{minted}


Opérations sur la pile : 
\begin{minted}{asm}
push eax        ; empilage, ici de la valeur eax
pop rbx         ; dépilage, ici dans rbx
push 0x12       ; empilage de 8 octets (avec des zeros)
pushf           ; "push rflags"
popf            ; "pop rflags"  
\end{minted}

Instructions de contrôle (où next\_ins désigne l'adresse de l'insruction suivante) : 
\begin{minted}{asm}
jmp 0x1234      ; rip = 0x1234 <=> goto 0x1234
jmp [0x1234]    ; rip = [0x1234]
jmp rax         ; rip = rax
jmp [rax]       ; rip = *rax
jz 0x1234       ; si ZF rip = 0x1234 sinon rip = next_ins
; jnz (not zero), jle (lower or equal), jg (greater), etc
\end{minted}

Appels de fonctions
\begin{minted}{asm}
call 0x1234 ; push next_ins; rip = 0x1234
ret         ; pop rip
call rbx
call [rax+0x12]
call [0x1234]
leave       ; rsp = rbp, pop rbp
\end{minted}

Interruptions
\begin{minted}{asm}
int3        ; interruption, utilisée par le debugger
\end{minted}

\chapter{De la machine au programme}

Lorsqu'on double-clique sur un programme, il est exécuté. Le système d'exploi\-tation va mettre en place la mémoire virtuelle pour le processus, charger les bibliothèques, initialiser les registres, en d'autres termes, préparer la configuration initiale du programme. Dans ce chapitre, on va voir ce qui se passe plus en détails. 

\section{Le programme en mémoire}

Dans un premier temps, observons la structure de la mémoire au démarrage d'un programme. Les expériences sont présentées en \C sous Windows. Pour Linux, il y a pleins de variations, mais on retrouve assez rapidement les analogies. Compilons le programme suivant (cf. github::basics/starting.c) : 

\begin{minted}[linenos]{C}
#include "stdafx.h"
#include <stdlib.h>
char a ='A',b='B';
int _tmain(int argc, char *argv[]){
  int i = 42, j;
  int *p =(int *) malloc(sizeof(int));
  printf("[%p] = %d\n", &i, i);
  printf("[%p] = %c\n", &a, a);
  printf("[%p] = %x\n", p, *p);
  printf("_tmain = %p\n", _tmain);
  printf("printf = %p\n", printf);
  return 0;
}
\end{minted}

A l'exécution du programme, on trouve  quatre grandes zones de mémoire visibles (avec un des droits R, W, X) à l'utilisateur :  le programme lui-même, la pile, le tas, et la zone des bibliothèques partagées. Plus en détail : 
\begin{itemize}
	\item La pile contient typiquement : les variables locales des fonctions (\code{i, j}), les adresses de retour des appels de fonctions. On retrouve donc une adresse dans la pile à la ligne 7. 
	\item Le tas contient toutes les données allouées dynamiquement, typiquement avec la fonction \code{malloc}, ligne 9.  
	\item   Le programme va contenir les instructions (\code{main}, ligne 10), les variables globales (\code{a},\code{b}, ligne 8), et différentes ressources (icones, etc). 
	\item  Enfin, les DLLs ont la même structure que l'exécutable lui-même (\code{msvcr.dll} qui contient le code de \code{printf}, ligne 11). %Elles vont avoir leur propre pile, leur propre tas, etc. 
\end{itemize}

En résumé, 

\medskip
\begin{memory}
m = Memory(12, 0.6)
m.zone(6,8,"red!10")
m.mark(6,"EXE")
m.content(6,"$\code{4D}\ldots$")
m.zone(1,2,"purple!20")
m.mark(1.5, "STACK")
m.zone(3.5,5,"green!20")
m.mark(4.2, "HEAP")
m.zone(9,10,"blue!20")
m.mark(9.5, "KERNEL32.dll")
m.zone(10.5,11.5,"blue!20")
m.mark(10.9, "MSVCR100.dll",1)
m.content(1,"\code{RWX}",0)
m.content(3.5,"\code{RWX}",0)
m.mark(1.5, "\&i:12FF74", 0.5, 1)
m.mark(4.2, "p:304018", 0.5, 1)
m.mark(6.6, "\_tmain:401000", 0.5, 1)
m.mark(7.2, "\&a:403018",1,0)
m.mark(11, "printf:78B056B4", 0.5, 1)
m.bar(1,2,8,3.5,5,9,10,10.5,11.5)
\end{memory}

Si on fait un zoom sur le programme lui-même, on obtient la structure suivante (avec une compilation standard sous VisualC) : 

\bigskip
\begin{memory}
m = Memory(12, 0.6)
m.zone(2,11,"red!10")
m.bar(2,3.5,5,6.5,8,9.5,11)
m.mark(2., "header")
m.mark(3.5, ".text")
m.mark(5,".rdata")
m.mark(6.5,".data")
m.mark(8,".reloc")
m.mark(9.5,".rsrc")
m.mark(2,"\code{400000}",0.5,1)
m.mark(3.5,"\code{401000}",0.5,1)
m.mark(5,"\code{402000}",0.5,1)
m.mark(6.5,"\code{403000}",0.5,1)
m.mark(8,"\code{404000}",0.5,1)
m.mark(9.5,"\code{405000}",0.5,1)
m.mark(11,"\code{406000}",0.5,1)
m.content(2.,"\code{RX}",0)
m.content(3.5,"\code{RX}",0)
m.content(5.,"\code{R}",0)
m.content(6.5,"\code{RW}",0)
m.content(8.,"\code{RW}",0)
m.content(9.5,"\code{R}",0)
m.content(11., "\ldots", 0)
m.content(1,"\ldots", 0)
\end{memory}

Le header du programme spécifie l'adresse de base, \code{400000}, le nom, la position relative, la taille, les droits en mémoire associé à chacune des sections~:\code{.text, .rdata}, etc. Il spécifie également les DLL importées, la taille de la pile demandée ainsi que la taille du tas. Voir la Section~\ref{sec:pe} sur la structure du PE pour plus de détails. 


\section{Promenade dans le PE} \label{sec:pe}

Les fichiers exécutables de \Windows\ suivent le format PE.  Lors de leur exécutions, il vont être mis en mémoire virtuelle. Dans cette section, écrite d'après : 
\begin{itemize}
	\item \url{https://learn.microsoft.com/en-us/previous-versions/ms809762(v=msdn.10)}
\end{itemize}
nous allons revenir sur le format en question. Globalement, un fichier exécutable de \Windows\ a la structure : 
\begin{itemize}
	\item une partie \code{DOS},
	\item un \code{header} pour la partie \code{PE}
	\item et une liste de sections.
\end{itemize} 

\begin{tikzpicture}
\fill[blue!30] (0,0) -- (14,0) -- (14,2) -- (0,2) -- cycle;
\fill[red!20] (0.1,0.1) -- (2,0.1) -- (2,1.9) -- (0.1,1.9) -- cycle;
\fill[yellow!20] (2.1,0.1) -- (5,0.1) -- (5,1.9) -- (2.1,1.9) -- cycle;
\fill[green!20] (5.1,0.1) -- (7.5,0.1) -- (7.5,1.9) -- (5.1,1.9) -- cycle;
\fill[green!20] (7.6,0.1) -- (9.6,0.1) -- (9.6,1.9) -- (7.6,1.9) -- cycle;
\fill[green!20] (12,0.1) -- (13.9,0.1) -- (13.9,1.9) -- (12,1.9) -- cycle;
\node at (1,1) {\begin{tabular}{c}\code{DOS}\\ \code{HEADER}\end{tabular}};
\node at (3.5,1) {\begin{tabular}{c}\code{PE/NT}\\ \code{HEADER}\end{tabular}};
\node at (6.2,1) {\begin{tabular}{c}\code{SECTION}\\ \code{HEADER}\end{tabular}};
\node at (8.4,1) {\begin{tabular}{c}\code{SECTION}\\ \code{1}\end{tabular}};
\node at (12.9,1) {\begin{tabular}{c}\code{SECTION}\\ \code{k}\end{tabular}};
\node at (10.2,1) {\huge \ldots};
\end{tikzpicture}

Ceci correspond à la structure C suivante : 

\begin{minted}{C}
typedef struct{
PIMAGE_DOS_HEADER     dos_header;
PIMAGE_NT_HEADERS   nt_header;
PIMAGE_SECTION_HEADER sections;
} pefile32_t;
\end{minted}


\medskip
Globalement, le fichier contient : 
\begin{itemize}
	\item des informations pour préparer la zone de mémoire correspondant à  l'exécutable,
	\item des informations pour mettre en place les DLL,
	\item et des informations pour préparer la pile et le tas.
\end{itemize}



\medskip
Voici un extrait d'un exécutable vu sous \url{https://ide.kaitai.io} : 

\medskip
\noindent
\begin{tikzpicture}
\node (A) at(0,0) {\includegraphics[width=7cm]{img/pe_basic_structure.png}};
\node (B)[below right=-46mm and 2mm of A] {\includegraphics[width=7cm]{img/kaitai_view_on_pe.png}};
\end{tikzpicture}

%Le format des exécutables modernes de \Windows\ est le format PE, lui-même une extension du format DOS (celui des années 80). En quelques lignes, 

\begin{itemize}
	\item La première partie est la partie DOS. Ells suit une structure qui s'appelle \code{IMAGE\_DOS\_HEADER}, accessible dans \code{"Windows.h"}. Elle commence par le 'magic number' \code{4d 5a}, \code{MZ} en \code{ascii}, "MZ" étant les initiales de Mark Zbikowski, un des développeurs de DOS.  A l'octet \code{3c}, on trouve la position du point d'entrée de la structure propre au format PE (Portable Executable).
	\item La partie \code{PE} commence par "PE" en \code{ascii}, \code{50 45}. Elle suit la structure \code{\_IMAGE\_NT\_HEADERS} dont on reparlera plus en détail ci-dessous.
	\item Le nom, la taille, la position relative, les droits de chaque section de l'exécutable sont spécifiés en séquence  après le header \code{\_IMAGE\_NT\_HEADERS}. 
	%\item Enfin, le code se clôt avec un certificat.  
\end{itemize}

La partie \code{PE} est spécifiée comme suit : %commence par \code{PE} en \code{ascii}, \code{50 45}. Elle suit la structure 
\begin{minted}{C}
typedef struct _IMAGE_NT_HEADERS {
  DWORD                   Signature;	//magic=50 45 00 00
  IMAGE_FILE_HEADER       FileHeader;	
  IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32;
\end{minted} 

%La signature est la suite de caractères \code{50 45 00 00}.
 La structure \code{FileHeader} contient les informations suivantes : 

\begin{minted}{C}
typedef struct _IMAGE_FILE_HEADER {
  WORD  Machine;		//indique si on est sur 32 ou 64 bits
  WORD  NumberOfSections;       //nombre de sectiosn
  DWORD TimeDateStamp; /
  DWORD PointerToSymbolTable;   //servait pour le debugger
  DWORD NumberOfSymbols;        //pareil
  WORD  SizeOfOptionalHeader;
  WORD  Characteristics;        // le type de fichier : DLL, EXE, etc
} IMAGE_FILE_HEADER,
\end{minted}

La partie \code{OptionalHeader} contient de nombreuses informations nécessaires au chargement du programme en mémoire. 

\begin{minted}{C}
typedef struct _IMAGE_OPTIONAL_HEADER {
WORD                 Magic;		    //is it 32 or 64 bits ?
BYTE                 MajorLinkerVersion;
BYTE                 MinorLinkerVersion;
DWORD                SizeOfCode;	   	//size of X pages
DWORD                SizeOfInitializedData;
DWORD                SizeOfUninitializedData;
DWORD                AddressOfEntryPoint;
DWORD                BaseOfCode;
DWORD                BaseOfData;
DWORD                ImageBase;
DWORD                SectionAlignment;    	//usually 0x1000
DWORD                FileAlignment;
WORD                 MajorOperatingSystemVersion;
WORD                 MinorOperatingSystemVersion;
WORD                 MajorImageVersion;
WORD                 MinorImageVersion;
WORD                 MajorSubsystemVersion;
WORD                 MinorSubsystemVersion;
DWORD                Win32VersionValue;		    //must be 0
DWORD                SizeOfImage;  	//size of the exe in memory
DWORD                SizeOfHeaders;
DWORD                CheckSum;	  	//checksum of the file
WORD                 Subsystem;
WORD                 DllCharacteristics;	 //info for DLLs
DWORD                SizeOfStackReserve;	 //stack size required
DWORD                SizeOfStackCommit;  	//"initialized" stack
DWORD                SizeOfHeapReserve;     		//for heap
DWORD                SizeOfHeapCommit;
DWORD                LoaderFlags;			//deprecated
DWORD                NumberOfRvaAndSizes; //number of directory_entries
IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32
\end{minted}

Les éléments du tableau \code{DataDirectory}, de type \code{IMAGE\_DATA\_DIRECTORY}, sont des  tables/des structures  qui contiennent des informations complémentaires (listées ici par ordre d'importance). Chaque entrée a le type : 

\begin{minted}{C}
typedef struct _IMAGE_DATA_DIRECTORY {
  DWORD VirtualAddress;
  DWORD Size;
} IMAGE_DATA_DIRECTORY
\end{minted}
qui donne la position relative de la structure en mémoire et sa taille. Il y a 16 structures/tables (listées ici par ordre d'importance) :  

\bigskip
\begin{tabular}{| l | l |}
	\hline
Value	&Meaning \\
\hline
0 & Export directory\\
12&Import address table\\
1&Import directory \\
5 &Base relocation table\\
9 & Thread local storage directory\\
7 &Architecture-specific data \\
11&Bound import directory\\
14&COM descriptor table\\
6&Debug directory\\
13&Delay import table\\
3 &Exception directory \\
8 & The relative virtual address of global pointer\\
10 &Load configuration directory\\
2 & Resource directory \\
4& Security directory \\
\hline
\end{tabular}


\begin{commentaire}{En bref}
La table EAT (Export Address Table) contient une structure liant : un nom de fonction, son ordinal et sa position relative dans l'exécutable. Au chargement d'une bibliothèque partagée par un exécutable $E$, l'OS lit cette table pour retrouver les adresses des fonctions appelées par $E$.


La table IAT (Import Address Table) contient une structure liant le nom des fonctions importées et les addresses correspondantes. Après avoir retrouvé les addresses des fonctions dans la table d'export de la bibliothèque associée, l'OS remplit la table des adresses.  
\end{commentaire}

Enfin, le code contient une liste d'éléments de type \code{IMAGE\_SECTION\_HEADER} pour chaque section. La structure permet de positionner les octets de la section en mémoire. 

%Il est découpé en blocs de \code{0x400} octets. Le premier bloc comprend les deux headers \code{DOS HEADER} et \code{PE/NT HEADER} qui contiennent les informations pour le chargement du programme en mémoire. Ensuite, on trouve le contenu de chaque sections octet par octet.

Le fichier est structuré en blocs de taille \code{IMAGE\_OPTIONAL\_HEADER.FileAlignment}, en général \code{0x200} ou \code{0x400} octets alors que la mémoire l'est en page de \code{0x1000} octets. Il peut donc y avoir des zones non spécifiées. Typiquement, on retrouvera un écart entre le fichier et la mémoire virtuelle : 

\bigskip
\begin{memory}
m = Memory(10,0.6)
m.content(0,"\code{header}s")
m.content(2,"\code{.text}")
m.content(4,"\code{.rdata}")
m.content(6,"\code{.data}")
m.content(8,"\code{...}")
n = Memory(12,0.6,-2)
n.content(0,"\code{headers}")
n.content(2.5,"\code{.text}")
n.content(5,"\code{.rdata}")
n.content(7.5,"\code{.data}")
n.content(10,"\code{...}")	
angles = [(2,2.5),(4,5),(6,7.5),(8,10)]
lignes = [Path((b-0.5,-1.4),(a,0),(b,-1.4),color="black") for a,b in angles] + [Path((0,0),(0,-1.4),color="black")]
for a,b in angles:
	n.zone(b-0.5,b,bgcolor="black!10",color="black")
for p in [2,4.5,7,9.5,10]:
	n.bar(p)
n.mark(0,"\code{400000}",0.5,0)
n.mark(2.5,"\code{401000}")
n.mark(5,"\code{402000}")
n.mark(7.5,"\code{403000}")
m.mark(0,"\code{0}",0.5,1)
m.mark(2,"\code{800}",0.5,1)
m.mark(4,"\code{1600}",0.5,1)
m.mark(6,"\code{2400}",0.5,1)
draw(*lignes)
draw(m,n)
\end{memory}

Que valent les octets dans la zone grise ? Ils ne sont pas spécifiés. C'est la raison pour laquelle {\sc ida} nous les présente sous la forme de "?" : 

\includegraphics[width=8cm]{img/ida_zone_non_specifiee.png} 

L'adresse \code{0x403200} ne correspond à aucune position dans le fichier. La valeur vient du fait que l'alignement se fait sur \code{0x200}. 


\subsection{Reconstruire l'exécutable à partir de l'adresse de base}

Pour avoir accès aux différentes parties d'un exécutable stocké en mémoire à l'addresse \code{p},  nous allons employer la structure fournie par \Windows: 
\begin{minted}{C}
int parse_pe_in_mem(void *p, pefile32_t & pe){
	pe.dos_header = (PIMAGE_DOS_HEADER) p;
	pe.nt_header = (PIMAGE_NT_HEADERS) 
		(((char*) p) + pe.dos_header->e_lfanew);
	pe.sections = (PIMAGE_SECTION_HEADER) 
		((char*)pe.nt_header + sizeof(IMAGE_NT_HEADERS));
	return 0;
}
\end{minted}

En particulier, un exécutable peut retrouver assez facilement sa propre structure à partir du pointeur d'instruction. Par ce biais, il peut ensuite modifier sa propre IAT par exemple. 

\begin{minted}{C}
uint32_t p = (uint32_t) _tmain ; // or any other function of the program
p = p & 0xfffff000 ; //for alignement on the page
char *base = (char *) p;
while ( memcmp(base, "MZ", 2) != 0){ base = base - 0x1000 ; }
\end{minted}

\`A la suite de ce code, le pointeur \code{base} pointe au début de l'exécutable en mémoire. Evidemment, il se peut que nous n'ayons pas de chance : qu'une page de mémoire entre le pointeur de départ et le début de l'exécutable commence précisément par "M" et "Z". Faite mieux !

\subsection{Exploiter la table EAT}

Voyons comment utiliser la table EAT. La première fonction récupère la table EAT. La seconde réimplémente la fonction \code{GetProcAddress} à partir de l'addresse de base de la structure et d'un nom de fonction \code{name}. En d'autres termes, le code qui suit permet de retrouver "discrètement" une fonction intéressante. 

\begin{minted}{C}
typedef PIMAGE_EXPORT_DIRECTORY PED;

PED get_eat(pefile32_t &pe){
  BYTE * ImageBase = (BYTE *)pe.dos_header ;
  PIMAGE_DATA_DIRECTORY entries = pe.nt_header->OptionalHeader.DataDirectory;
  uint32_t eat_rva = (uint32_t) entries[0].VirtualAddress;
  return (PED) ((uint32_t) pe.dos_header + eat_rva);
}

void * get_fun_address_by_name(pefile32_t &pe,const char *name){
  BYTE * ImageBase = (BYTE *)pe.dos_header ;
  PED eat = get_eat(pe);
  uint32_t *pNameAddr = (uint32_t*)(ImageBase + eat->AddressOfNames);
  uint32_t *pFuncAddr = (uint32_t *)(ImageBase + eat->AddressOfFunctions);
  for(uint32_t i = 0; i < eat->NumberOfFunctions; i++){
    const char *pFunc = (const char *)(ImageBase + pNameAddr[i]);
    if(strcmp(name,pFunc) == 0)
      return (void*)(ImageBase + pFuncAddr[i]);
  }
  return NULL;
}
\end{minted}


\section{La structure PEB}\label{sec:peb}

La structure PEB, Process Environment Block, est une structure interne à \code{Windows} qui lui permet de gérer le processus. On y retrouve des informations intéressantes : 
\begin{itemize}
	\item le fait que le processus soit en mode Debug ou non, 
	\item la liste des modules (des DLLs) chargés (cf. \code{Ldr}),
	\item la ligne de commande initiale (cf. \code{ProcessParameters}).
\end{itemize}

Sa définition en C (les champs réservés sont omis) : 
\begin{minted}{C}
typedef struct _PEB {
	BYTE                          Reserved1[2];
	BYTE                          BeingDebugged;
	...
	PPEB_LDR_DATA                 Ldr;
	PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
	...
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	...
	ULONG                         SessionId;
} PEB, *PPEB;
\end{minted}

Et \code{PostProcessInitRoutine} est "Not supported". Comprenne qui pourra. 

Si on rentre plus en détail dans la structure, la liste des DLL d'un processus est accessible. Fort utile si l'on veut récupérer une adresse discrètement.  

\subsection{Accéder à la structure PEB}

L'ensemble du code ci-dessous est disponible dans le fichier \code{win/peb.cpp}. Par le moyen "direct", en demandant à \Windows. 

\paragraph{Via la fonction NtQueryInformationProcess}

\begin{minted}{C}
typedef NTSTATUS(NTAPI* ptQuery)(HANDLE, UINT, PVOID, ULONG, PULONG);
...
PROCESS_BASIC_INFORMATION basicinfo;
HMODULE ntdll = LoadLibraryW(L"ntdll.dll");
ptQuery query = NULL;
query = (ptQuery)GetProcAddress(ntdll, "NtQueryInformationProcess");
query(GetCurrentProcess(), ProcessBasicInformation, 
& basicinfo, sizeof(PROCESS_BASIC_INFORMATION), NULL);
PPEB ppeb  = basicinfo.PebBaseAddress;
\end{minted}

Pourquoi s'embêter à retrouver l'adresse de la fonction "NtQueryInformationProcess", plutôt que de l'appeler directement comme suit : 

\begin{minted}{C}
PROCESS_BASIC_INFORMATION basicinfo;
NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, 
& basicinfo, sizeof(PROCESS_BASIC_INFORMATION), NULL);
PPEB ppeb  = basicinfo.PebBaseAddress;
\end{minted}

Et bien, on trouve une note de Microsoft :  "The NtQueryInformationProcess function and the structures that it returns are internal to the operating system and subject to change [...] If you do use NtQueryInformationProcess, access the function through run-time dynamic linking. This gives your code an opportunity to respond gracefully if the function has been changed or removed from the operating system." 




\paragraph{Avec 2 lignes d'assembleur}

\begin{minted}{asm}
PPEB ppeb;
__asm{
  mov eax, fs:[0x30]
  mov ppeb, eax
}
\end{minted}

\paragraph{Par la table TEB}

\begin{minted}{asm}
PPEB ppeb;
__asm{
mov eax, fs:[0x18]
mov ebx, [eax+0x30]
mov ppeb, ebx
}
\end{minted}



\subsubsection{Une application : {\tt echo} avec la structure PEB}

Voyons comment retrouver les arguments du programme avec la table PEB. Nous allons reprogrammer un simple echo : 

\begin{minted}{C}
int main(int argc, char *argv[]){
  for(int i = 0 ; i < argc ; i++) printf("%s ", argv[i]);
  return 0;
}
\end{minted}
mais en se compliquant un peu la vie, enfin, celle de la personne qui fera l'analyse de notre \code{echo.exe}.  

\begin{minted}{C}
int main(int argc, char *argv[]){
  PPEB ppeb;
  //code to get the ppeb
  PRTL_USER_PROCESS_PARAMETER pp = ppeb->ProcessParameters;
  printf("%S\n", pp->CommandLine.Buffer);   
  return 0;
}
\end{minted}


\subsection{La petite s\oe ur, la table TEB}

C'est une table équivalente, mais pour les threads, Thread Environment Block. Elle contient de très nombreuses informations sur le thread courant. La récupérer peut se faire comme ci-dessus :

\begin{minted}{asm}
void *teb = (void *) __readfsdword(0x18);
\end{minted}

ou de manière équivalente : 

\begin{minted}{asm}
void *teb;
__asm{
mov eax, fs:[0x18]
mov teb, eax
}
\end{minted}


On retrouve alors de nombreuses informations comme : la position de la pile en mémoire, la gestion des exceptions, la position du PEB, etc. 


\section{La section TLS}

C'est une section prévue pour gérer les Thread (Local Storage). Prévue pour initialiser les variables locales aux Threads, elle permet d'invoquer du code "avant" le main. Une astuce contre les debuggers. Voici un exemple d'emploi de threads. 

\begin{minted}{C}
PPEB ppeb;
__asm{
  mov eax, fs:[0x30]
  mov ppeb, eax
}
\end{minted}




\chapter{Obfuscations}

Dans ce chapitre, nous montrons des exemples d'obfuscations. Les possibilités sont évidemment innombrables. Ici, nous en faisons un florilège avec l'idée de montrer les mécanismes mis en \oe uvre les plus importants. 

Les obfuscations sont en charge de protéger l'exécutable contre son analyse. Ces dernière sont de plusieurs ordres. 

Premier point. L'analyste peut faire une étude du code via son fichier binaire. On parle d'analyse statique. Il va essayer de reconstituer la liste des instructions du code, instructions qui contiennent la "logique" (la sémantique) de l'exécutable. L'objectif pour la protection est d'empêcher un tel désassemblage. La cible de ces obfuscations sont des outils comme {\tt IDA}, {\tt Ghidra}, {\tt Radare} qui sont des désassembleurs bien connus. Dans les titres qui suivent, ils sont notés (A). 

Deuxième point. Comme une analyse statique est par principe toujours partielle, il est tentant d'exécuter le code pour en déterminer le comportement. Cela peut se faire de plusieurs manières. Le code peut être exécuté par un debugger. L'objectif de la protection est d'empêcher/reconnaître le debugger. Ce sera l'objet de la section~\ref{sec:anti-debug}. Ici, les techniques vont s'attaquer à des outils de debug ou de virtualisation comme {\tt windbg}, {\tt ollydbg}, {\tt cukoo}, etc. Dans les titres qui suivent, ils sont notés (D). 

Troisième point. A supposer que l'analyste arrive à debugger le programme, il faut encore être en mesure de poser des points d'arrêts. Les codes auto-modifiants, ou code produits à la volée, ne sont pas accessibles au départ. Difficile de mettre un point d'arrêt à un endroit qui n'existe pas encore. De manière moins anecdotique, la liste des instruction devient fonction de l'exécution. Cela rend fort relatif la notion de graphes de flot de contrôle. Ils sont notés (S). 

Quatrième point. Si l'automodification rendait relatif la notion de code, il reste que l'analyse se réduit à un seul processus. On verra qu'il y a moyen de passer au delà. Ils sont notés (P).


Les codes proposés ont été testés sur la machine virtuelle du cours. Note~: il s'agit d'une machine WindowsXP 32bits. La plupart des techniques peuvent être transposées pour d'autres OS/architectures. Par ordre de difficulté des transpositions : 
\begin{itemize}
	\item un Windows parmi Win7, 8, 10 sous X86, 32 bits,
	\item un Windows parmi Win7, 8, 10, 11 sous X86, 64 bits,
	\item un Linux, X86, 32 ou 64 bits,
	\item les autres cas. 
\end{itemize}

Les codes qui suivent ont été compilés en mode 'RELEASE' avec VisualC.  Les codes sont écrits dans un esprit de clarté. Pour cette raison, 
\begin{itemize}
	\item Les entêtes sont souvent omises. Seule les bibliothèques spécifiques sont précisées. 
	\item Certains algorithmes peuvent être optimisés. 
	\item Il n'y a aucune gestion des erreurs. 
\end{itemize}


\section{Cacher l'appel de la fonction (A)}

L'utilisation de fonctions, en particulier celles provenant des bibliothèques, donne bien sûr beaucoup d'informations sur ce que fait le programme. Les désassembleurs donnent les noms de fonctions des bibliothèques en clair. Cela simplifie largement l'analyse. C'est la raison pour laquelle les appels de fonctions sont généralement obfusqués. On propose quelques techniques dans cette section. 

\paragraph{Par un procédé direct}

Le code suivant récupère l'adresse de \code{printf} directement : 

\begin{minted}[linenos]{C}
#include <Windows.h>
typedef int (*type_printf)(const char *, ...);
int _tmain(int argc, _TCHAR *argv[]){
HMODULE msvcrt = LoadLibraryA("msvcrt");
type_printf f = (type_printf)GetProcAddress(msvcrt, "printf");
f("Hello world");
...}
\end{minted}

\begin{commentaire}{Mais, ce n'est pas très discret}
	D'abord, parce qu'ici, le nom de la fonction est en clair, \code{"printf"}, on pourrait le chiffrer pour éviter le souci. Mais surtout parce que maintenant, il faut cacher l'appel à \code{GetProcAddress}. Ce qui nous conduit à suivre des méthodes alternatives. 
	
	\medskip On peut utiliser des version alternatives pour le nom de la DLL \code{msvcr100.dll}, \code{msvcr.dll}, \code{MSVCR}, etc. 
	
	\medskip Le "A" dans \code{LoadLibraryA} indique que la chaîne de caractère est donnée en {\sc ascii}. Pour des \code{widechar} (sur deux octets), on utilise \code{LoadLibraryW} (avec un "L" avant la chaine pour indiquer le codage \code{widechar}). 
	
	\vspace{1ex}
\noindent	\mintinline{C}{msvcrt = LoadLibraryW(L"msvcrt");}
\end{commentaire}

\paragraph{Par écart en mémoire à une fonction connue}{~}

\begin{minted}[linenos]{C}
typedef int (*type_printf)(const char *, ...);
int _tmain(int argc, _TCHAR *argv[]){
/* compute delta 
int delta = ((int) printf) - ((int) scanf)
*/
int delta = -1200;
unsigned int address = (unsigned int) scanf;
address += delta;
type_printf f = (type_printf) address;
f("Hello world");
...}
\end{minted}

Une technique vue dans {\tt Duqu}. La fonction \code{printf} est dans la même bibliothèque que \code{scanf} (en l'occurence {\sc msvcrt.dll} dans le monde {\sc windows}). Si la bibliothèque n'est pas modifiée, l'écart en mémoire entre \code{printf} et \code{scanf} est fixé (et peu importe l'ASLR). De ce fait, il suffit de précalculer (Ligne 4) l'écart entre les deux pour retrouver l'adresse de \code{printf}. 

\bigskip

\begin{memory}
m = Memory(12, 0.6)
m.mark(7,"\\tt printf")
m.mark(9,"\\tt scanf")
m.mark(7, "78B056B4", 0.5, True)
m.mark(9, "- 78B05B64 = ", 0.5, True)
m.content(7, "6A 0C \\ldots")
m.bar(9)
m.add_node((10.5,1.38), "-1200")
\end{memory}




%\input{| python truc.py hum hoo} %\getstored{outer}}}

\begin{commentaire}{Fragilités}
\`A la moindre mise à jour de la DLL, l'écart entre les deux fonctions peut changer. D'où la méthode suivante un peu plus robuste. 	
\end{commentaire}

\paragraph{Par signature}{~}

Dans le schéma qui précède, on peut aller plus loin. Le début du code de \code{printf} est~: 
\mint{asm}{6a 0c 68 60 57 b0 78 e8 c0 b5 fa ff}

L'idée est de chercher en mémoire une zone à laquelle on trouve précisément ces octets. Et comme \code{printf} n'est pas très loin de \code{scanf}, autant commencer par explorer la mémoire à partir de cette dernière fonction. 

\begin{minted}{C}
char *signature = "\x6a\x0c\x68\x60\x57\xb0\x78\xe8\xc0\xb5\xfa\xff";
char *p = (char *)scanf;
int found = 0;
while (!found){
  if (memcmp(p, signature, 12) == 0){ found = 1; }
  else{ p--; }
}
type_printf f = (type_printf) p;
f("Hello world");
...}
\end{minted}
 
\begin{commentaire}{Toujours des fragilités}
Attention, selon qu'on est en mode 'DEBUG' ou 'RELEASE', les octets ne sont pas tout à fait les mêmes. Et si le code source de \code{printf} ne change vraisemblablement pas beaucoup d'une version de la DLL à l'autre, des changements d'options du compilateur peuvent modifier les octets de la signature. 

\medskip Une telle signature ressemble fortement à une signature dite "Flirt" qu'on retrouve dans IDA, un extrait :  

\mint{asm}{558BECB8....5DC3.... 00 0000 000A :...___local_stdio_printf... }
\end{commentaire}

\begin{exercice}{A gauche où à droite ?}
	On a commencé à partir de \code{scanf} en partant vers les adresses basses. Mais peut-être eut il fallu aller vers la droite. Comment faire mieux ? 
\end{exercice}

\paragraph{Par la table PEB}~

La table en question donne accès aux bibliothèques, et par ce biais aux fonctions. L'exemple qui suit reprend l'idée de signature. Mais en passant par l'image de base de la DLL, on est sur d'explorer la mémoire dans le bon sens, vers les adresses hautes.  

\begin{minted}[linenos]{C}
int _tmain(int argc, _TCHAR *argv[]){
...
PPEB ppeb  = ...;
PLDR_DATA_TABLE_ENTRY ple  = get_dll_handle(ppeb, L"MSVCR");
char *p = (char *) ple->DllBase;
int found = 0;
while (!found){
  if (memcmp(p, signature, 12) == 0){ found = 1; }
  else{ p++; }
}
type_printf f = (type_printf) p;
f("Hello world");
...}
\end{minted}

On retrouvera le code des lignes 3 et 4 à la section sur la structure {\tt PEB}~\ref{sec:peb}. 

\begin{commentaire}{Pour faire mieux}
	On peut éviter une boucle \code{while} infinie en se limitant à la taille de la DLL, taille qu'on peut retrouver directement via la variable \code{ple}. 
\end{commentaire}

Un autre exemple, où l'on passe par la table d'export (voir la section~\ref{sec:peb} pour les lignes 2, 3, 4). 

\begin{minted}[linenos]{C}
int _tmain(int argc, _TCHAR *argv[]){
PPEB ppeb  = ...
pefile32_t  msvcr = get_dll_pe(ppeb, L"MSVCR");
type_printf f = (type_printf) get_fun_by_name(msvcr, "printf");
f("Hello world");
...}
\end{minted}

\paragraph{En jouant avec la table d'import}~

Nous avons vu que les adresses des fonctions importées étaient stockées en mémoire. Ce n'est pas très difficile de les modifier. Voici un exemple ou on échange l'adresse de \code{printf} et celle de \code{scanf}.

\begin{minted}[linenos]{C}
uint32_t * get_fun(uint32_t fun, void * base_pointer){
	uint32_t *p = (uint32_t *) base_pointer;
	while (1) { if (*p == fun) return p;
	  p++;
	}
	return NULL;
}

int _tmain(int argc, _TCHAR* argv[]){
	uint32_t atscan = (uint32_t) scanf, atprint = (uint32_t) printf;
	uint32_t * pos_printf = get_fun(atprint, _tmain );
	uint32_t * pos_scanf = get_fun(atscan, _tmain);
	DWORD old;
	VirtualProtect(pos_printf, 0x10, PAGE_READWRITE, &old);
	*pos_printf = atscan;
	*pos_scanf = atprint;
	...
	scanf("Hello world %d", sum);
	...
\end{minted}

La fonction \code{get\_fun} retrouve la position dans l'IAT où la fonction \code{fun} est stockée. Implicitement, on fait l'hypothèse que l'adresse cherchée est alignée avec le pointeur de base modulo 4 (la taille d'un pointeur \code{uint32\_t}). La table IAT se trouve souvent dans une section READONLY, d'où l'appel à \code{VirtualProtect}


\begin{commentaire}{Pour aller plus loin}
	Reconstituer une table d'import à la manière de l'algorithme du système. Attention, cela peut prendre du temps. 
\end{commentaire}

\section{Contre le debug (D)}

Debugger sert aussi à la rétro-ingénierie du code. Les analyses statiques sont limitées, et on peut essayer de retrouver des valeurs critiques en exécutant le programme analysé avec un debugger. 

 Les malwares étant protégés contre leur analyse, ils vont s'attaquer aux débugger. La présence d'un debugger est visible par plusieurs procédés. 

\paragraph{En demandant à \Windows}

\begin{minted}{C}
#include "Windows.h"
...
if (IsDebuggerPresent()){
	//diversion
}
...
\end{minted}

Tout l'art est alors d'avoir une bonne diversion, une qui ne met pas la puce à l'oreille du défenseur. 

\paragraph{En demandant encore à \Windows}

\begin{minted}{C}
#include "Windows.h"
...
DWORD res;
CheckRemoteDebuggerPresent(GetCurrentProcess(), &res));
if (res) {
//diversion
}
...
\end{minted}

\begin{commentaire}{Mais pourquoi donc ?}
	Mais à quoi peut servir la fonction \code{CheckRemoteDebuggerPresent} ? Quand un processus est débuggé, il "émet" des interruptions de débug. Celles-ci sont rattrapées par un handler d'exception. Mais il n'est pas prévu que deux handlers s'occupent de la même exception. Et de ce fait, utiliser deux débugger peut poser problème.  
\end{commentaire}

\paragraph{Pareil, mais sans demander}~


Vu à la section~\ref{sec:peb}, la structure PEB contient un flag "DEBUG" : 

\begin{minted}{C}
...
PPEB ppeb = ...
if (ppeb->BeingDebugged){
  //diversion
}
...
\end{minted}

Dans une version "hack" : 

\begin{minted}{C}
...
PPEB ppeb = ...
char * p = (char *) ppeb;
if (p[104] & 0x70){
//diversion
}
...
\end{minted}

\begin{commentaire}{Mais d'où cela vient il ?}
Faisons confiance à la communauté. Même si l'octet 104 est dans un des champs non renseignés de la documentation \Windows, il y a toujours quelqu'un qui est allé regarder ce qui s'y passe. Ici, citons : \url{https://www.aldeid.com/wiki/PEB-Process-Environment-Block/NtGlobalFlag}.

L'octet en question contient des flags pour la vérification du tas. Le flag est détourné dans ce cas.   
\end{commentaire}

\paragraph{Par vérification de l'intégrité du code}~

\medskip
Quand on pose un point d'arrêt sur une instruction, le debugger modifie le code exécuté en remplaçant l'instruction par 
\mintinline{asm}{int3}
autrement dit \code{CC}. Cette instruction déclenche une interruption (de DEBUG) qui est rattrapée par le debugger. Mais un attaquant peut prévoir de protéger une fonction et vérifier son intégrité. Le code suivant interdit de mettre un point d'arret sur le code de la fonction \code{fonction\_critique}.

\begin{minted}[linenos]{C}
__declspec(noinline) int fonction_critique(int x, int y){
	int z = x+y;
	for(int i = 0 ; i < z ; i += 2){
		printf("%d", i+z);
		z+=1;
	}
	return z;
}

int _tmain(int argc, _TCHAR* argv[]){	
	char s = 0;
	for(char * p = (char*) fonction_critique; 
		p != (char *)_tmain; 
		p++){ 
	s += *p;
	}
	printf("%d", s);
	if (s != -113) printf("good joke\n");
	else { int z = fonction_critique(argc, argc); }
	...
\end{minted}

La valeur $-113$ a été déterminée par une première exécution. Implicitement, la boucle de la ligne 13 fait l'hypothèse que la fonction \code{fonction\_critique} apparaît en mémoire avant la fonction \code{\_tmain}. 


\paragraph{Contre un debugger en particulier}~

\medskip Il est aussi possible de tuer le processus en charge de debugger. Occupons nous de \code{windbg}. On peut lister les processus jusqu'à retrouver celui qui nous intéresse. Evidemment, comme contre-mesure, on peut envisager changer le nom de {\tt windbg}. 

\begin{minted}{C}
bool isDebug(){ //windbg
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (Process32First(snapshot, &entry) ){
        while (Process32Next(snapshot, &entry) ) {
            if (wcscmp(entry.szExeFile, L"windbg.exe") == 0){
               return 1;
            }
        }
    }
     return 0;
}
\end{minted}


\section{Contre les motifs de compilation (A)}

En utilisant des constructions hors schéma de compilation standard, on peut dérouter les désassembleurs. On rappelle que le désassemblage est problématique quand on rencontre des instructions dont le contrôle (la valeur de {\tt rip} à venir) est déterminée par la configuration (et pas dans le fichier exécutable).  Les instructions immédiatement problématiques sont : 
\begin{itemize}
	\item \code{jmp eax}, \code{jmp [eax]}, \code{jmp [eax+4ecx]}, etc,
	\item \code{call eax}, \code{call [eax]}, etc,
	\item \code{ret}
\end{itemize}

Elles demandent l'évaluation d'un registre ou de l'état de la mémoire. Deux tâches indécidables en général. 

Il y a d'autres instructions qui peuvent être problématiques : celles levant une exception vont amener l'intervention du noyau. De ce fait, le programme perd la main et le retour dans le programme ne peut être déterminé simplement. 
\begin{itemize}
	\item \code{idiv ebx} peut lancer une \code{EXCEPTION\_INT\_DIVIDE\_BY\_ZERO}.
	\item \code{int3}, interruption de DEBUG,
	\item une instruction illégale (mais qui peut être rattrapée par ailleurs), 
	\item une instruction "normale" mais qui viole un droit en mémoire.	
\end{itemize}

Venons maintenant aux exemples. 

\paragraph{Via un saut indirect}



\section{Automodifications (S)}

Dans ce qui a été vu auparavant, nous avions au moins un élément solide sur lequel appuyer l'analyse : la liste des instructions est fixée une fois pour toute, ce sont celles qu'on voit au chargement du programme. Les retrouver peut être difficile, mais elles ne sont pas dépendantes des exécutions. Avec les automodifications, le code se transforme lui même au cours du temps, la liste des instructions est relative aux exécutions, et non plus absolue (présente dans le fichier). 

Commençons par une automodification toute simple : 

\begin{minted}[linenos]{C}
char fonction[]= {'\x90','\x90','\x90','\xc3'};

typedef void (*typeFonction) (); 
int main(){
        typeFonction mf = (typeFonction) &fonction;
        mf();
        printf("done");
	...
}
\end{minted}

Le lecteur aura reconnu dans le tableau {\tt fonction} les instructions {\tt 90 = nop} et {\tt c3 = ret}. En d'autres termes, la fonction  fait trois fois rien et s'arrête. Evidemment, ce programme ne fait rien d'intéressant. Toutefois, il fonctionne. D'autre part, il montre qu'en {\sc windows XP}, la mémoire correspondant à la section {\tt .data} a les droits en exécution. Ce n'est plus le cas des {\sc windows} plus modernes.  

On pourra reprocher à ce code d'être présent au départ. C'est vrai, mais il est à un endroit où ce n'est pas prévu. En outre, la variable {\tt fonction} étant un tableau de {\tt char} peut être modifiée au cours du temps. On pourra donc réécrire le code précédent de la manière suivante : 

\begin{minted}[linenos]{C}
char fonction[]= {'\x90' ^ 42 , '\x90' ^42 ,'\x90' ^42 ,'\xc3' ^ 42};

typedef void (*typeFonction) (); 
int main(){
        typeFonction mf = (typeFonction) &fonction;
        for (int k = 0 ; k < 4 ; k++) fonction[k] ^= 42;
        mf();
        printf("done");
	...
}
\end{minted}

Dans ce cas, les instructions correspondant à la {\tt fonction} sont déchiffrée ligne 6, juste avant l'appel  ligne 7.

\paragraph{La gestion des droits de la mémoire}

Il est possible d'enrichir l'exemple qui précède en écrasant du code déjà présent. Dans ce cas, non seulement des instructions apparaissent au cours de l'exécution, mais d'autres disparaissent. La liste des instruction est donc relative à chaque instant. Si on analyse une zone de mémoire, disons que l'on reconnait par exemple une boucle de chiffrement, cette zone est relative à cet instant précis. Plus tard, un code tout à fait différent peut remplacer le contenu présent.

Si on veut modifier le contenu de la section {\tt .text}, on a un petit souci technique. Cette zone de mémoire n'a pas les droits en écriture. Il faut donc faire un appel à {\tt VirtualProtect}, typiquement comme ceci : 

\begin{minted}[linenos]{C}
char fonction[]= {'\x90', '\x90','\x90','\xc3'};

typedef void (*typeFonction) (); 
int main(){
        char *p = (char *) main;
        typeFonction mf = (typeFonction) p;
        DWORD old;
	VirtualProtect(p, 0x4, PAGE_EXECUTE_READWRITE, &old);
        for (int k = 0 ; k < 4 ; k++) p[k] = fonction[k];// recopie le code
        mf();
        printf("done");
	...
}
\end{minted}

\paragraph{La notion de vague}

Nous avons vu que du code produisait du code, et donc que celui-ci devenait relatif aux exécutions. Mais comment distinguer des écritures légitimes de données en mémoire  d'écritures d'instructions ? Dans le premier cas, on assiste à une exécution normale, pas dans le second. Il y a un argument qui fait basculer d'un cas à l'autre : si on exécute une instruction à une adresse où il y a eu écriture. Dans notre premier exemple, les instructions étaient {\em déjà là}, il n'y a donc pas eu de réécriture en mémoire. Mais pour tous les autres cas, il y a bien écriture en mémoire (à l'occasion du chiffrement dans un cas, de l'écrasement dans l'autre) suivi d'une exécution d'une instruction à une adresse où il y a eu écriture (lors de l'appel à la fonction {\tt mf}).

On définit les vagues de la manière suivante. Au départ, le programme est considéré à la vague $0$. Il entre à la vague $1$ au moment où une instruction exécutée correspond à une adresse où il y a eu écriture à la vague $0$. Et le mécanisme peut continuer. Il entre à la vague $2$ au moment où une instruction exécutée correspond à une adresse où il y a eu écriture à la vague $1$. Et ainsi de suite. 

\begin{formalisme}{Vague}
Soit une trace d'exécution d'un programme $P$, c'est-à-dire une suite $(a_0, i_0), (a_1, i_1), (a_2,i_2), \ldots$ où $a_n$ désigne l'adresse de la $n$-ième instruction exécutée et $i_n$ l'instruction elle-même. Pour chaque instant, on note $w(n)$ l'ensemble des adresses des cellules mémoire écrites par l'instruction $i_n$. 

 La vague $0$ est l'instant $0$.  La vague $1$ est le plus petit entier $m$ tel que $a_m \in \cup_{0 \leq n < m} w(n)$. Plus généralement, la vague $k+1$ est le plus petit entier $m$ tel que $a_m \in \cup_{  m_k \leq n < m} w(n)$ où $m_k$ désigne la vague $k$. 
\end{formalisme}

On pourra noter, de manière incidente, que pendant une vague, par définition, toutes les instructions exécutées sont déjà présentes en mémoire {\em au début de la vague}. Pendant la durée de la vague, le code peut être considéré comme {\em non automodifiant}. Par conséquent, le début des vagues est un bon moment pour faire une analyse de code. On sait que toutes les instructions exécutées pendant la vague sont dans  la mémoire au début de la vague. C'est une bonne raison de faire un dump à ce moment là. 

\paragraph{Code caché}

Supposons qu'un analyste observe notre programme en cours d'exécution. Il est possible qu'il fasse un dump de la mémoire à un moment donné. Disons alors que le pointeur d'instruction est à l'adresse $a$. Notre analyste est susceptible de regarder si à cet endroit en mémoire au début de l'exécution on a la même instruction que celle observée dans le dump. Si ce n'est pas le cas, il sait qu'il y a eu automodification. Mais quelle partie du code initial a produit l'instruction en question ?

Si une instruction $i_0$ de la vague $0$ a produit (écrit en mémoire) une instruction $i_1$ (de la vague $1$ par conséquent) qui elle même a produit l'instruction $i_2$  à l'adresse $a$, aucune partie initiale du code n'a produit l'instruction $i_2$ observée. Autrement dit, on a une instruction dont on ne sait pas d'où elle sort.  C'est une bonne raison d'enchaîner les vagues de code.

Mais on peut aller plus loin dans ce scénario. L'instruction $i_2$ peut elle-même écraser l'instruction $i_1$ en mémoire. Si notre analyste a le malheur de faire son dump juste après $i_2$, il observe une instruction $i_2$ qui n'a pas été produite par le code initial et en outre, l'instruction qui l'a produite n'est pas dans le dump mémoire. On dit que la vague $2$ \emph{écrase} la vague $1$.


\paragraph{Mais comment écrire du code automodifiant  en pratique ?}

Dans les exemple que nous avons vu, nous avons produit directement le code machine. Mais on ne parle pas tous cette langue couramment. Aussi, pour écrire du code plus sophistiqué, il convient d'avoir une stratégie plus globale. Imaginons que nous ayons une fonction à cacher. 

\begin{minted}[linenos]{C}
int f(int x, int y){
	...
}
\end{minted}

Rien n'interdit de la compiler, et ensuite d'extraire les octets de la fonction dans le binaire. La tâche consiste alors a reproduire la suite d'octets en mémoire, et à lancer une fonction à cet endroit. 

Toutefois, nous sommes ici tributaires de la compilation de la fonction par le compilateur. Il peut :
\begin{enumerate}
\item ne pas compiler la fonction si elle n'est pas employée dans le code,
\item inliner la fonction,
\item compiler la fonction, mais optimiser le code aux cas rencontrés. Typiquement, si vous n'utilisez que la fonction avec des nombres positifs et qu'il y a un test \mintinline{C}{if (x > 0)}, celui-ci peut disparaitre. 
\item utiliser des références à des adresses relatives. Par exemple, on pourra retrouver une instruction comme \mintinline{asm}{ mov ebx, [eax+12]} où la valeur de {\tt eax} est la différence en mémoire entre la position d'une variable globale $a$ et la position de l'instruction courante. On retrouve ce motif dans un appel de fonction interne par exemple.
\end{enumerate}

Alors, quelques pistes de solution pour contourner ces motifs de compilation. 
\begin{enumerate}
\item il faut prévoir au moins un appel de la fonction dans le code préliminaire,
\item on peut utiliser \mintinline{C}{__declspec(noinline) }
\item il faut prévoir des appels qui vont couvrir tous les cas d'emploi, on peut également compiler en enlever les optimisations, XXX figure
\item il faut éviter les variables globales, on peut les passer comme paramètres de la fonction .
\item pour les fonctions locales, on trouvera des adresses relatives. Il faut alors les modifier à la main, ou utiliser des pointeurs de fonction. Pour les fonctions dans des bibliothèques, l'adresse peut également être relative, et dans ce cas, il faut patcher le code produit. 
\end{enumerate}

Devant les difficultés, il peut être intéressant d'écrire le code directement en assembleur. Bien sûr, on pourra s'appuyer sur un code compilé pour aller plus vite. En pratique, si la fonction n'est pas très longue, cela peut aller rapidement.  Et souvent, il est nécessaire de faire une dernière passe à la main, en modifiant directement les quelques instructions qui font des références à des adresses de manière relative. Pour ces dernières, on peut directement modifier l'instruction. Passer par exemple de \mintinline{asm}{mov eax, 0x2a == "B8 2A 00 00 00"} à \mintinline{asm}{mov eax, 0x33 == "B8 33 00 00 00"}. 


\section{Défense contre le patch (D, S)}

Rien n'interdit à l'analyste de patcher le code analysé. En faisant cela, il prend le risque de modifier  les exécutions. Mais il pourra quand même observer celles-ci au moins partiellement. Par exemple, il pourra éviter une méthode anti-debug sans trop de difficulté. Si le patch n'est pas trop intrusif, il pourra avoir une bonne vue de ce qui se passe. 

Mais rien n'interdit à l'écrivain du malware de prévoir cela. Il est donc tout à fait possible que le code du malware vérifie sa propre intégrité. Nous avons vu un tel mécanisme dans la section sur les méthodes anti-debug. Mais cela peut être également envisagé de manière plus générale.  Typiquement, le code à la vague $n+1$ est susceptible de vérifier que le code de la vague $n$ n'a pas été modifié par l'analyste.

Dans l'exemple suivant, on vérifie dans le {\tt main} l'intégrité du code de la fonction {\tt f}
\begin{minted}[linenos]{C}
int sum(char *p, char *q){
	int s = 0; 
	for(; p != q ; p++) s += *p;
	return s;
}
int f(int x, int y){
...
}
int main(){
	char *p = (char *) f;
	//int magic = sum(f, (char *) main);
	int magic = MAGIC;
	int test = sum(f, (char *) main);
        if (test != magic){
        	//patch found
        } 
	...
}
\end{minted}
où la constante  {\tt MAGIC} à la ligne 12 correspond à la valeur  précalculée à la ligne 11. 

Quand on veut vérifier l'intégrité d'une fonction, la position de départ est assez simple à définir. Par définition, l'énoncé {\tt f} pour une fonction désigne l'adresse de sa première instruction. Mais comment désigner l'adresse de la dernière instruction de la fonction ? Plusieurs possibilités. On compile la fonction, on regarde son code compilé, et on récupère la taille par analyse manuelle. Deuxième possibilité, on introduit un {\tt canary} dans la fonction qui donnera la position finale. Troisième possibilité, celle qui est faite dans le code précédent, on fait l'hypothèse que le code compilé positionne en mémoire les fonctions les unes après les autres. Si on connait la fonction qui suit, on peut s'y arrêter.

Petite note : ici, on fait l'hypothèse que le compilateur va placer en mémoire la fonction {\tt f} entre la fonction {\tt sum} et la fonction {\tt main}. L'ordre d'apparition des fonctions dans le code compilé est relativement stable. En outre, il est toujours possible de vérifier a posteriori que le code est bien dans l'ordre voulu. 

\begin{commentaire}{Se vérifier soi-même}
Bien sûr, dans le cas présent, on ne vérifie que l'intégrité de la fonction {\tt f} dans {\tt main}. Et pour ceux qui aiment réfléchir, si on veut vérifier l'intégrité de {\tt main} dans {\tt main}, il n'est pas si facile de calculer la constante {\tt MAGIC}, et même peut être pas possible. En tous les cas, rien n'interdit qu'une autre fonction, appelée par {\tt main} fasse elle-même le travail. Le code de {\tt main} reste inchangé, la constante étant dans la fonction auxiliaire. 
\end{commentaire}

\begin{commentaire}{Tromper la vérification}
Rien n'interdit au défenseur de repérer la vérification d'identité. Et de patcher la vérification en question. Mais alors, l'attaquant peut vérifier que la vérification n'a pas été usurpée. Et l'histoire peut continuer longtemps. 
\end{commentaire}



\section{Mécanismes multi-processus}

Jusque là, les obfuscations que nous avons vues laissent au moins un élément absolu : les instructions exécutées correspondent à un exécutable en particulier. Mais nos machines permettent à plusieurs processus de co-exister et même de travailler ensemble. Pourquoi ne pas faire faire une partie du travail à un processus et une autre à un autre. Après tout, c'est bien comme cela qu'on procède pour de grands projets logiciels.

Evidemment, il y a deux possibilités de répartir le calcul, on peut le faire via des threads ou via des processus. Dans le premier cas, on reste avec un seul exécutable, mais un calcul réparti, dans l'autre, on a plusieurs processus distincts. Dans tous les cas, pour l'analyste, la tâche devient plus compliquée. Comprendre un algorithme séquentiel est toujours plus simple que son équivalent réparti. Par exemple, debugger devient vite plus compliqué : il faut gérer les points d'arrêts, le temps devient relatif au thread (ou au processus) et simplement reconnaitre les points de synchronisation peut être difficile. 

Mais cela ne reste que de la (bonne) programmation, l'objet d'un cours sur les calculs répartis. Ce que l'on va faire ici est un peu différent. Nous allons mettre en oeuvre des mécanismes qui sortent de la programmation honnête.

\paragraph{L'emploi d'une DLL}

Afin de séparer physiquement l'exécutable d'une fonction qu'on voudrait garder secrète, on peut utiliser une DLL. Dans le code suivant, on défini une fonction qui sera exportée par la DLL:
\begin{figure}[H]
\begin{minted}[linenos]{C}
__declspec(dllexport) int thekey(int iv){
	return iv + 42;
}
\end{minted}
\caption{MyLib.cpp}
\end{figure}
Pour appeler la DLL, on peut l'inclure statiquement (voir la documentation de Microsoft) ou faire un appel direct à la bibliothèque : 

\begin{figure}[H]
\begin{minted}[linenos]{C}
typedef int (*secret_function) (int);
int _tmain(int argc, _TCHAR* argv[]){
  HMODULE mylib = LoadLibraryA("C:\\MyLib.dll");
  secret_function secret;
  secret = (secret_function) GetProcAddress(mylib, "?thekey@@YAHH@Z");
  printf("%d", secret(argc));
  return 0;
}
\end{minted}
\caption{MonExe.cpp}
\end{figure}

A la ligne 5, on voit apparaître \code{"?thekey@@YAHH@Z"} qui est la version décorée de \code{"thekey"} (on parle de "mangling" dans la littérature). Le langage C++ définit la décoration pour tenir compte de la surcharge des fonctions de sorte que deux fonctions ayant le même nom mais des arguments différents soient exportées avec des noms différents. Les éléments de décoration décrivent le profil de la fonction. 

\paragraph{Se faire passer pour un autre}

On peut commencer simplement. Supposons que la "payload" soit le programme \mintinline{C}{hostname.exe}. On pourra écrire un exécutable qui lance la "payload". Evidemment, il vaudrait mieux faire en sorte de ne pas mettre en clair le nom du programme ciblé. 

\begin{minted}[linenos]{C}
int main(char *p, char *q){
  STARTUPINFOA si = { sizeof(si) };
  PROCESS_INFORMATION pi;
  CreateProcessA(NULL, "C:\\Windows\\System32\\hostname.exe", \
  		0, 0, FALSE, 0, 0, 0, &si, &pi);
  WaitForSingleObject(pi.hProcess, INFINITE);
  CloseHandle(pi.hProcess);
  CloseHandle(pi.hThread);
}
\end{minted}

%Dans le cas qui précède, l'exécutable est tout à fait innocent. Il lance juste un nouveau processus. Evidemment, on ne laissera pas en clair le nom de la charge. 

\paragraph{Injection dans un autre exécutable}

L'idée est de faire faire par un exécutable {\tt EXE} des actions "malveillantes". Pour cela, un procédé "simple" est de faire charger par l'{\tt EXE} lui-même une DLL qui contient la charge. Afin d'y parvenir, on va avoir besoin de a) allouer de la mémoire dans un autre processus, b) modifier le contenu de ce bloc et c) lancer un thread dans {\tt EXE}. Voyons cela de plus près : 

\begin{minted}{C}
...
//PID = pid de l'exe à infecter
process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
char * path = "chemin_vers_la_DLL\\Polueur.dll";
int dll_length = strlen(path);
LPVOID base_address  = VirtualAllocEx(process, NULL, dll_length, //"malloc"
                       MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);//cf doc Microsoft
SIZE_T N;
WriteProcessMemory(process, base_address, path, dll_length, & N); //"memcpy"
CreateRemoteThread(process, NULL,0,(LPTHREAD_START_ROUTINE)LoadLibraryA, 
                                                  base_address, 0, NULL);
 //attendre un petit peu
 \end{minted}



\chapter{L'analyse dynamique}

Quand l'analyse statique échoue pour une raison ou une autre, on peut être amené à utiliser un débogueur. Mais quand le débogueur ne fonctionne pas, on pourra essayer une analyse dynamique. Elle consiste à exécuter le binaire, mais en gardant, au moins partiellement, un contrôle sur l'exécution du code.


L'outil d'analyse dynamique que nous allons utiliser est  {\sc PIN}, un outil maintenu par {\sc intel}. Il y en a bien d'autres, citons {\sc dynamorio} qui est le plus proche de {\sc PIN}, et les "bacs à sable" comme {\tt Qemu}, {\tt TequilaBoomBoom}, etc. D'autres procédures d'analyse dynamique s'appuient sur l'introspection comme {\sc Drakvuf}, mais cette dernière technique demande de consacrer une machine pour faire tourner l'hyperviseur. Nous avons choisi {\sc PIN} pour la simplicité de l'installation et le fait qu'il rende correctement compte de ce qui est possible en analyse dynamique. 

L'objectif de ce chapitre n'est pas de présenter {\sc PIN} sous toutes les coutures, mais de montrer en quoi l'analyse dynamique permet de répondre à des questions de retro-ingénierie. De manière générale, j'invite le lecteur à se reporter à la documentation d'{\sc INTEL} qui est bien plus complète que ce que nous allons faire ici. 

Le principe  est le suivant : {\sc PIN} prend deux entrées, un exécutable {\tt M.exe} à analyser et une DLL {\tt D.dll} qui va contrôler l'exécution de {\tt M.exe}.  La commande qui suit exécute le programme {\tt M.exe} avec les arguments {\tt argv1}, {\tt argv2}, \ldots en étant contrôlé par {\tt D.dll}. 

\begin{minted}[linenos]{C}
pin.exe -t D.dll -- M.exe argv1 argv2 ...
\end{minted}

Pour être un peu plus complet, {\sc PIN}  peut également s'attacher sur un processus existant, à la manière d'un débogueur. Il peut également s'attacher à un nouveau processus au démarrage. 

La DLL d'analyse est produite en C/C++ à l'aide de l'a bibliothèque fournie par {\sc INTEL}. On retrouvera un exemple de projet avec les liens déjà préparés sur la machine virtuelle.  L'exemple le plus simple est le suivant : 

\begin{minted}[linenos]{C}
int main(int argc, char *argv[]){
  PIN_Init(argc, argv); //transmits the args to M.exe
  PIN_StartProgram();//starts M.exe
  return 0;
}
\end{minted}

Ensuite, on se donne des fonctions de callback. Chacune va prendre en compte un des évènements : 
\begin{itemize}
\item La fin de l'exéuction : \code{PIN\_AddFiniFunction},
\item Le chargement d'un module (l'exécutable ou une bibliothèque partagée) : \code{IMG\_AddInstrumentFunction}
\item Le "chargement" d'une instruction qui n'a pas été exécutée auparavant : \code{INS\_AddInstrumentFunction}.
\end{itemize}

Voici quelques exemples typiques d'utilisation de chacune des fonctions d'instrumentation.

\paragraph{La fonction \code{PIN\_AddFiniFunction}} 

Etant donné une fonction :

\begin{minted}{C}
VOID fini(UINT32 status, VOID *v){ ... } 
\end{minted}

un appel :

\begin{minted}{C}
PIN_AddFiniFunction(fini, v)} 
\end{minted}

va déclencher l'appel à la fonction \code{fini}  à la terminaison du programme. La fonction \code{fini} a deux arguments \code{INT32 status} qui donne  le statut de sortie et le pointeur \code{VOID *v} dont la valeur est le deuxième argument de la fonction \code{PIN\_AddFiniFunction}. La fonction peut être utilisée pour la fermeture des fichiers par exemple. 


\begin{minted}[linenos]{C}
VOID fini(INT32 status, FILE *file){
  fprintf(file, "Code exit with status %d\n", status);
  close(file);
}
int main(int argc, char *argv[]){
  FILE *logfile = fopen("my_analysis.log", "w")
  PIN_Init(argc, argv); //transmits the args to M.exe
  PIN_AddFiniFunction(fini, file);
  PIN_StartProgram();//starts M.exe
  return 0;
}
\end{minted}


\paragraph{La fonction \code{IMG\_AddInstrumentFunction}} La fonction de callback est appelée au chargement de chaque module. Elle prend deux arguments, \code{IMG img} et \code{VOID *v}, le premier est un pointeur sur une structure qui contient des informations à propos du module, le second est celui qui vient de l'appel de la fonction \code{IMG\_AddInstrumentFunction}. 

Sachant que le premier module chargé est le programme lui-même, le code qui suit donne la position en mémoire de l'exécutable. Ceci peut être fort utile pour sélectionner les addresses qui correspondent à la zone de l'exécutable. 

\begin{minted}[linenos]{C}
VOID module(IMG, VOID *v){
  cout << IMG_Name(img) << ": " << IMG_StartAddress(img) << 
          " - " << IMG_HighAddress(img) << "\n";
}
int main(int argc, char *argv[]){
  PIN_Init(argc, argv);
  IMG_AddInstrumentFunction(module, NULL);
  PIN_StartProgram();//starts M.exe
  return 0;
}
\end{minted}

Cette fonction est fort utile pour filtrer les instructions qui nous intéressent~: classiquement, on va ne garder que celles qui sont dans l'exécutable, pas les instructions des bibliothèques. 


 \paragraph{Quelques fonctions sur les images}
\begin{verbatim}
VOID ImageUnload(IMG img, VOID *v)
IMG_AddInstrumentFunction(ImageLoad, 0);
IMG_Name(img)
IMG_LowAddress(img)
IMG_HighAddress(img)
 \end{verbatim}
 
\paragraph{La fonction \code{INS\_AddInstrumentFunction}} La fonction de callback est appelée au chargement de chaque nouvelle instruction. Elle a deux arguments, \code{INS ins} qui donne accès à des informations sur l'instruction, et le pointeur \code{VOID *v} que l'on a déjà vu. Le programme qui suit permet d'afficher la liste de toutes les instructions rencontrée lors de l'exécution : 

\begin{minted}[linenos]{C}
VOID instruction(INS ins, VOID *v){
  cout << INS_Address(ins) << ": " << INS_Disasm(ins) << "\n"; 
}
int main(int argc, char *argv[]){
  PIN_Init(argc, argv);
  INS_AddInstrumentFunction(instruction, NULL);
  PIN_StartProgram();//starts M.exe
  return 0;
}
\end{minted}

Premier point. Vu le nombre d'instructions, on est rapidement débordé par la taille des sorties. Deux possibilités : on met le résultat dans un log et on le gère avec un post-traitement,  ou on filtre les instructions considérées. Par exemple, pour ne voir que les instructions qui sont dans le programme lui-même, en exploitant la fonction \code{IMG\_AdddInstrumentFunction} pour initialiser les variables \code{low} et \code{high}, on pourra les utiliser comme ci-dessous : 
\begin{minted}{C}
  ADDRINT eip = INS_Address(ins);
  if (eip >= low && eip <= high){ 
  cout << INS_Address(ins) << ": " << INS_Disasm(ins) << "\n"; 
  }
\end{minted}

Deuxième point. Ce programme ne permet pas d'observer les boucles. En effet, seules les instructions nouvellement chargées font l'objet d'un appel à la fonction de callback. Pour exécuter une fonction à chaque passage par une instruction, {\sc pin} va transformer l'instruction à la volée. L'exemple qui suit affiche les addresses des instructions, instruction par instruction : 

\begin{minted}[linenos]{C}
VOID ins2(ADDRINT eip){
cout << hex << eip << endl ;  
}

VOID instruction(INS ins, VOID *v){
 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) ins2, 
 			IARG_INST_PTR, IARG_END);
}
\end{minted}

La fonction \code{INS\_InsertCall} demande les arguments suivants. Le premier, {\tt ins}, est l'instruction sur laquelle on veut exécuter la fonction \code{ins2} à chaque passage dans l'instruction. L'argument \code{ IPOINT\_BEFORE} indique que la fonction \code{ins2} sera exécutée \emph{avant} l'instruction elle-même. Après l'argument \code{ins2}, on trouve une description des arguments qui seront transmis à la fonction \code{ins2}. Ici, \code{IARG\_INST\_PTR} (le pointeur d'instruction \code{eip}) suivi d'aucun autre argument \code{ IARG\_END}. 

Nous allons maintenant enrichir l'ensemble de ces fonctions pour affiner les analyses. 

\paragraph{La valeur d'un registre}

\begin{verbatim}
 VOID print_eax(uint32_t  eax){
  	cout << hex <<  eax << '\n' ; 
 }
 ...
 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) print_eax,  
               IARG_REG_VALUE, REG_EAX, IARG_END);
  \end{verbatim}
  
\paragraph{Le passage du contexte : pour plusieurs registres }

\begin{verbatim}
 VOID print_two_regs (CONTEXT *ctxt ){
        UINT32 eax = (UINT32) PIN_GetContextReg(ctxt, REG_EAX);
        UINT32 esp = (UINT32) PIN_GetContextReg(ctxt, REG_EAX);  
  	cout << hex <<  eax <<  " " << esp << ' \n' ; 
 }
 ...
 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) print_two_regs,  
              IARG_CONTEXT, IARG_END);
  \end{verbatim}
  
 \paragraph{Le passage d'un pointeur}
\begin{verbatim}
 VOID print_ins(string *s){
  	cout << s  << ' \n' ; 
 }
 ...
 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) print_ins,  
              IARG_PTR, new string(INS_Disassemble(ins)), IARG_END);
  \end{verbatim}

 \paragraph{Le cas des instructions qui font référence à la mémoire}
 
 En écriture : 
 
\begin{verbatim}
 VOID print_ea(void *ea){
  	cout << ea  << ' \n' ; 
 }
 ...
 
 //INS_MemoryOperandCount retourne le nombre de références à la mémoire
for( UINT32 i = 0 ; i < INS_MemoryOperandCount(ins) ;++i){
         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) print_ea,  
	IARG_MEMORYOP_EA, i, IARG_END)
  }
 \end{verbatim}
 
 Ce qui précède peut être raffiné en filtrant les arguments lus ou écrits en mémoire avec les fonctions respectives  \code{INS\_MemoryOperandIsRead(ins, memOp)} et    \code{INS\_MemoryOperandIsWritten(ins, memOp)}. 
 
 \paragraph{Lecture directe de la mémoire}

En supposant que notre code soit compilé par nos soins et dont l'image de base est \code{0x400000}, on pourra retrouver les lettre 'MZ' comme suit : 


\begin{verbatim}
 VOID print_mz(){
        char * mz = (char *) 0x400000;
        if ( PIN_CheckReadAccess(mz)  ) //vérifie que le processus peut acceder en mz
	  	cout << mz  << ' \n' ; 
 }
\end{verbatim}	
 
\paragraph{Sur les{instructions}}
\begin{verbatim}
string *opcode = ;
INS_Size(ins)              ; taille de l'instruction
INS_Address(ins)        ; //eip
INS_NextAddress(ins) ; //instruction suivante
\end{verbatim}	

\paragraph{Gestion des arguments}
 \begin{verbatim}
 UINT32 memOperands = INS_MemoryOperandCount(ins);
 INS_MemoryOperandIsRead(ins, memOp)
 INS_MemoryOperandIsWritten(ins, memOp)
 INS_InsertCall(...,IARG_MEMORYOP_EA, memOp,..., IARG_END);
 // pour les registres
 INS_MaxNumWRegs(ins) : nombre de registres qui sont écrits
 INS_RegW(ins, i) // le ième registre écrit
 INS_MaxNumRRegs(ins) //pareil en lecture
 INS_RegR(ins, i) // pareil en lecture
 REG_EAX, REG_EIP, REG_ESP, ...
 \end{verbatim}
 
 
 \paragraph{Miscélannées : fonctions et noms}
 \begin{verbatim}
 RTN_FindNameByAddress( eip ) ;
 main(){
 ... PIN_InitSymbols()
 }
 \end{verbatim}
 
 
 \paragraph{Sections}
 dans une fonction \verb|IMG_fun(IMG img, VOID *)| 
 \begin{verbatim}
 for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
 SEC_Size(sec)
 SEC_Address(sec ) 
 SEC_Data(sec ) 	
 SEC_Name(sec )
 \end{verbatim}

\begin{exercice}{Retrouver "hello"}
On suppose que l'on voit apparaître "hello" sur la console. Retrouver la zone de mémoire qui fait référence à "hello". 
\end{exercice}

\begin{exercice}{Retrouver "printf"}
Retrouver tous les appels à la fonction "printf".  
\end{exercice}


\bibliographystyle{alpha}
\bibliography{references}	

\chapter{Prérequis}

\section{Les mots et les nombres}

Pour un processeur, l'alphabet est l'ensemble des nombres entre 0 et 255, autrement dit les octets.
Une suite de deux octets, s'appelle un mot\footnote{Ambiguité, ambiguité.}, une suite de quatre octets un mot double\footnote{Et pas un mot doux.} et une suite de huit octets un mot quadruple.

Une suite d'octets peut s'interpréter par un nombre. Plusieurs choix sont possibles, lecture de gauche à droite, de droite à gauche, par bloc, etc. Plus fondamentalement, l'interprétation va dépendre du processeur, et de la \emph{sorte du nombre} que l'on considère, entiers naturels (dits non signés), entiers relatifs (dits signés), réels (dits flottants).  Ainsi, un octet est interprété par une machine de deux manières différentes, selon que l'entier est considéré avec un signe ou sans~: 

\begin{center}
	\begin{tabular}{| c | c | c |}
		\hline
		octet & naturel & relatif\\
		\hline
		00000000 & 0 & 0\\
		\hline 00000001 & 1 & 1\\
		\hline 00000010 & 2 & 2\\
		\hline \ldots & \ldots & \ldots\\
		\hline 01111111 & 127 & 127\\
		\hline 10000000 & 128 & -128\\
		\hline 10000001 & 129 & -127\\
		\hline \ldots& \ldots & \ldots\\
		\hline 11111111 & 255 & -1\\
		\hline
	\end{tabular}
\end{center}

Pour l'architecture {\sc x86}, dite "little-endian", les entiers de taille 2, 4 ou 8 octets sont représentés partant des octets de poids faible. Pour un mot double, la séquence d'octets en mémoire $a_0, a_1, a_2, a_3$ représente l'entier naturel $a_0 + 256 \times a_1 + 256^2 \times a_2 + 256^3 \times a_3$. Ainsi, le nombre \code{0x12345678} apparaît il en mémoire comme cela : 
78 56 34 12, voir la note\footnote{Et l'on voit là l'intérêt de la notation hexadécimale. En décimal, ce nombre est \code{305419896} avec sa représentation en mémoire (en décimal): 120 86 52 18. Beaucoup moins clair, non ? }.

Voici un petit code en \C qui permet d'en faire l'expérience :
\begin{minted}{c}
int main(){
int x = 0x12345678;
char *p = (char *) & x;
for(int i = 0 ; i < 4 ; ++i) printf("%02x ", p[i] & 0xff);
}
\end{minted}

Les réels ont leur propre représentation, incompatible avec les précédentes. Par exemple, la suite de lettres {\tt 01010110\ 00001110\ 01001001\ 11000000} correspond à  $3226013270$ s'il est vu comme un entier non signé, $-1068954026$ pour un entier signé et  $-3.1415{\tt f}$ pour un flottant. 


\section{Les bases des bases}

Nous distinguons essentiellement quatre bases pour décrire les entiers naturels, la base $2$, la base $10$, la base $16$ et la base $256$. Les entiers décrits en base $2$ sont préfixés par {\tt 0b} à la manière de \python. Les premiers entiers sont {\bina{0}, \bina{1}, \bina{10}, \bina{11}, \ldots}.  Les nombres décimaux gardent leur notation habituelle.  Les entiers écrits en base 16, dits hexadécimaux, sont notés avec le préfixe $\tt 0x$. Les chiffres sont $\tt 0, 1, \ldots, 9, a, b, c, d, e, f$. Les chiffres hexadécimaux correspondent aux nombres binaires à 4 chiffres: $\hexa{0} = \bina{0} = 0, \ldots, \hexa{9} = \bina{1001} = 9, \ldots, \hexa{f} = \bina{1111} = 15$. 

Les chiffres de la base $256$ sont des octets. On les écrit avec deux chiffres hexadécimaux. Typiquement $\hexa{90}$. En \C, pour afficher l'octet d'un pointeur \mintinline{c}{char *p}, on utilisera : \mint{c}{printf("%02x", (*p) & 0xff);} 
	
	Notons qu'il n'y a pas de différence de nature entre \bina{1011}, 11 et \hexa{0b} : ce sont trois notations pour le même objet, le nombre qui s'écrit 11 en langage courant. Ainsi, écrire en C la ligne \mint{c}|int x = 0xab;|  ou la ligne \mint{c}|int x = 171;|  aboutit exactement au même résultat. 
	
	
	\section{Suites}
	Une suite est une liste indexée par un ensemble ordonné. $U = (i+1)_{i\in \N} = 1, 2, 3,\ldots$.  Les suites peuvent être finies comme $V = (i+2)_{0\leq i \leq 5} = 2, 3, 4, 5, 6, 7$. 
	
	Si $U = (u_1,\ldots, u_k)$ et $V=(v_1,\ldots,v_m)$ sont des suites finies, on note  $U+V = (u_1, \ldots, u_k, v_1,\ldots v_m)$. L'opération est associative, c'est-à-dire $(U+V)+T = U+(V+T)$. Attention, elle n'est pas commutative. 
	
	Une suite $U$ est préfixe d'une suite $V$ s'il existe une suite $T$ telle que $V = U+T$. Par exemple, $U = (1, 2, 3)$ est préfixe de $V = (1, 2, 3, 5, 8)$. 
	
	Par la suite, nous notons $M[i]$ l'octet à l'adresse $i$ de la mémoire virtuelle. Pour deux entiers $i < j$, $M[i \cdots j]$ désigne la suite d'octets $M[i], M[i+1], \ldots, M[j-1]$. Pour désigner les $n$ octets à partir de $i$, nous  emploierons la notation $M^n[i]$. 
	

\end{document}